{"ast":null,"code":"/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { createHtmlInternal, isHtml, unwrapHtml } from '../internals/html_impl.js';\nimport { unwrapResourceUrl } from '../internals/resource_url_impl.js';\nimport { unwrapScript } from '../internals/script_impl.js';\n/**\n * Returns HTML-escaped text as a `SafeHtml` object. No-op if value is already a\n * SafeHtml instance.\n *\n * Available options:\n * - `preserveSpaces` turns every second consecutive space character into its\n * HTML entity representation (`&#160;`).\n * - `preserveNewlines` turns newline characters into breaks (`<br>`).\n * - `preserveTabs` wraps tab characters in a span with style=white-space:pre.\n */\nexport function htmlEscape(value, options = {}) {\n  if (isHtml(value)) {\n    return value;\n  }\n  let htmlEscapedString = htmlEscapeToString(String(value));\n  if (options.preserveSpaces) {\n    // Do this first to ensure we preserve spaces after newlines and tabs.\n    htmlEscapedString = htmlEscapedString.replace(/(^|[\\r\\n\\t ]) /g, '$1&#160;');\n  }\n  if (options.preserveNewlines) {\n    htmlEscapedString = htmlEscapedString.replace(/(\\r\\n|\\n|\\r)/g, '<br>');\n  }\n  if (options.preserveTabs) {\n    htmlEscapedString = htmlEscapedString.replace(/(\\t+)/g, '<span style=\"white-space:pre\">$1</span>');\n  }\n  return createHtmlInternal(htmlEscapedString);\n}\n/**\n * Creates a `SafeHtml` representing a script tag with inline script content.\n */\nexport function scriptToHtml(script, options = {}) {\n  const unwrappedScript = unwrapScript(script).toString();\n  let stringTag = `<script`;\n  if (options.id) {\n    stringTag += ` id=\"${htmlEscapeToString(options.id)}\"`;\n  }\n  if (options.nonce) {\n    stringTag += ` nonce=\"${htmlEscapeToString(options.nonce)}\"`;\n  }\n  if (options.type) {\n    stringTag += ` type=\"${htmlEscapeToString(options.type)}\"`;\n  }\n  if (options.defer) {\n    stringTag += ` defer`;\n  }\n  stringTag += `>${unwrappedScript}\\u003C/script>`;\n  return createHtmlInternal(stringTag);\n}\n/**\n * Creates a `SafeHtml` representing a script tag with the src attribute.\n * This also supports CSP nonces and async loading.\n */\nexport function scriptUrlToHtml(src, options = {}) {\n  const unwrappedSrc = unwrapResourceUrl(src).toString();\n  let stringTag = `<script src=\"${htmlEscapeToString(unwrappedSrc)}\"`;\n  if (options.async) {\n    stringTag += ' async';\n  }\n  if (options.customElement) {\n    stringTag += ` custom-element=\"${htmlEscapeToString(options.customElement)}\"`;\n  }\n  if (options.defer) {\n    stringTag += ` defer`;\n  }\n  if (options.id) {\n    stringTag += ` id=\"${htmlEscapeToString(options.id)}\"`;\n  }\n  if (options.nonce) {\n    stringTag += ` nonce=\"${htmlEscapeToString(options.nonce)}\"`;\n  }\n  if (options.type) {\n    stringTag += ` type=\"${htmlEscapeToString(options.type)}\"`;\n  }\n  if (options.crossorigin) {\n    stringTag += ` crossorigin=\"${htmlEscapeToString(options.crossorigin)}\"`;\n  }\n  stringTag += '>\\u003C/script>';\n  return createHtmlInternal(stringTag);\n}\n/**\n * HTML-escapes the given text (`&`, `<`, `>`, `\"` and `'`).\n */\nfunction htmlEscapeToString(text) {\n  const escaped = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&apos;');\n  return escaped;\n}\n/** Creates a `SafeHtml` value by concatenating multiple `SafeHtml`s. */\nexport function concatHtmls(htmls) {\n  return joinHtmls('', htmls);\n}\n/**\n * Creates a `SafeHtml` value by concatenating multiple `SafeHtml`s interleaved\n * with a separator.\n */\nexport function joinHtmls(separator, htmls) {\n  const separatorHtml = htmlEscape(separator);\n  return createHtmlInternal(htmls.map(value => unwrapHtml(htmlEscape(value))).join(unwrapHtml(separatorHtml).toString()));\n}\n/**\n * Returns a `SafeHtml` that contains `<!DOCTYPE html>`.\n * This is defined as a function to prevent the definition of a Trusted Type\n * policy when simply importing safevalues.\n */\nexport function doctypeHtml() {\n  return createHtmlInternal('<!DOCTYPE html>');\n}\n/**\n * Non-exported version of `nodeToHtml`, with an explicit temporary root to\n * accomodate for the sanitizer's user case.\n */\nexport function nodeToHtmlInternal(node, temporaryRoot) {\n  temporaryRoot.appendChild(node);\n  // XML serialization is preferred over HTML serialization as it is\n  // stricter and makes sure all attributes are properly escaped, avoiding\n  // cases where the tree might mutate when parsed again later due to the\n  // complexities of the HTML parsing algorithm\n  let serializedNewTree = new XMLSerializer().serializeToString(temporaryRoot);\n  // We remove the outer most element as this is the span node created as\n  // the root for the sanitized tree and contains a spurious xmlns attribute\n  // from the XML serialization step.\n  serializedNewTree = serializedNewTree.slice(serializedNewTree.indexOf('>') + 1, serializedNewTree.lastIndexOf('</'));\n  return createHtmlInternal(serializedNewTree);\n}\n/**\n * Serializes a Node into it's HTML representation.\n *\n * Note: this method uses strict XML serialization to mitigate mutation issues\n * when the html is then re-parsed by the browser.\n */\nexport function nodeToHtml(node) {\n  const tempRoot = document.createElement('span');\n  return nodeToHtmlInternal(node, tempRoot);\n}","map":{"version":3,"names":["createHtmlInternal","isHtml","unwrapHtml","unwrapResourceUrl","unwrapScript","htmlEscape","value","options","htmlEscapedString","htmlEscapeToString","String","preserveSpaces","replace","preserveNewlines","preserveTabs","scriptToHtml","script","unwrappedScript","toString","stringTag","id","nonce","type","defer","scriptUrlToHtml","src","unwrappedSrc","async","customElement","crossorigin","text","escaped","concatHtmls","htmls","joinHtmls","separator","separatorHtml","map","join","doctypeHtml","nodeToHtmlInternal","node","temporaryRoot","appendChild","serializedNewTree","XMLSerializer","serializeToString","slice","indexOf","lastIndexOf","nodeToHtml","tempRoot","document","createElement"],"sources":["E:/HTML/Udemy_Full Stack Web/AI-SCET Website/aiscet/node_modules/safevalues/dist/mjs/builders/html_builders.js"],"sourcesContent":["/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { createHtmlInternal, isHtml, unwrapHtml, } from '../internals/html_impl.js';\nimport { unwrapResourceUrl, } from '../internals/resource_url_impl.js';\nimport { unwrapScript } from '../internals/script_impl.js';\n/**\n * Returns HTML-escaped text as a `SafeHtml` object. No-op if value is already a\n * SafeHtml instance.\n *\n * Available options:\n * - `preserveSpaces` turns every second consecutive space character into its\n * HTML entity representation (`&#160;`).\n * - `preserveNewlines` turns newline characters into breaks (`<br>`).\n * - `preserveTabs` wraps tab characters in a span with style=white-space:pre.\n */\nexport function htmlEscape(value, options = {}) {\n    if (isHtml(value)) {\n        return value;\n    }\n    let htmlEscapedString = htmlEscapeToString(String(value));\n    if (options.preserveSpaces) {\n        // Do this first to ensure we preserve spaces after newlines and tabs.\n        htmlEscapedString = htmlEscapedString.replace(/(^|[\\r\\n\\t ]) /g, '$1&#160;');\n    }\n    if (options.preserveNewlines) {\n        htmlEscapedString = htmlEscapedString.replace(/(\\r\\n|\\n|\\r)/g, '<br>');\n    }\n    if (options.preserveTabs) {\n        htmlEscapedString = htmlEscapedString.replace(/(\\t+)/g, '<span style=\"white-space:pre\">$1</span>');\n    }\n    return createHtmlInternal(htmlEscapedString);\n}\n/**\n * Creates a `SafeHtml` representing a script tag with inline script content.\n */\nexport function scriptToHtml(script, options = {}) {\n    const unwrappedScript = unwrapScript(script).toString();\n    let stringTag = `<script`;\n    if (options.id) {\n        stringTag += ` id=\"${htmlEscapeToString(options.id)}\"`;\n    }\n    if (options.nonce) {\n        stringTag += ` nonce=\"${htmlEscapeToString(options.nonce)}\"`;\n    }\n    if (options.type) {\n        stringTag += ` type=\"${htmlEscapeToString(options.type)}\"`;\n    }\n    if (options.defer) {\n        stringTag += ` defer`;\n    }\n    stringTag += `>${unwrappedScript}\\u003C/script>`;\n    return createHtmlInternal(stringTag);\n}\n/**\n * Creates a `SafeHtml` representing a script tag with the src attribute.\n * This also supports CSP nonces and async loading.\n */\nexport function scriptUrlToHtml(src, options = {}) {\n    const unwrappedSrc = unwrapResourceUrl(src).toString();\n    let stringTag = `<script src=\"${htmlEscapeToString(unwrappedSrc)}\"`;\n    if (options.async) {\n        stringTag += ' async';\n    }\n    if (options.customElement) {\n        stringTag += ` custom-element=\"${htmlEscapeToString(options.customElement)}\"`;\n    }\n    if (options.defer) {\n        stringTag += ` defer`;\n    }\n    if (options.id) {\n        stringTag += ` id=\"${htmlEscapeToString(options.id)}\"`;\n    }\n    if (options.nonce) {\n        stringTag += ` nonce=\"${htmlEscapeToString(options.nonce)}\"`;\n    }\n    if (options.type) {\n        stringTag += ` type=\"${htmlEscapeToString(options.type)}\"`;\n    }\n    if (options.crossorigin) {\n        stringTag += ` crossorigin=\"${htmlEscapeToString(options.crossorigin)}\"`;\n    }\n    stringTag += '>\\u003C/script>';\n    return createHtmlInternal(stringTag);\n}\n/**\n * HTML-escapes the given text (`&`, `<`, `>`, `\"` and `'`).\n */\nfunction htmlEscapeToString(text) {\n    const escaped = text\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&apos;');\n    return escaped;\n}\n/** Creates a `SafeHtml` value by concatenating multiple `SafeHtml`s. */\nexport function concatHtmls(htmls) {\n    return joinHtmls('', htmls);\n}\n/**\n * Creates a `SafeHtml` value by concatenating multiple `SafeHtml`s interleaved\n * with a separator.\n */\nexport function joinHtmls(separator, htmls) {\n    const separatorHtml = htmlEscape(separator);\n    return createHtmlInternal(htmls\n        .map((value) => unwrapHtml(htmlEscape(value)))\n        .join(unwrapHtml(separatorHtml).toString()));\n}\n/**\n * Returns a `SafeHtml` that contains `<!DOCTYPE html>`.\n * This is defined as a function to prevent the definition of a Trusted Type\n * policy when simply importing safevalues.\n */\nexport function doctypeHtml() {\n    return createHtmlInternal('<!DOCTYPE html>');\n}\n/**\n * Non-exported version of `nodeToHtml`, with an explicit temporary root to\n * accomodate for the sanitizer's user case.\n */\nexport function nodeToHtmlInternal(node, temporaryRoot) {\n    temporaryRoot.appendChild(node);\n    // XML serialization is preferred over HTML serialization as it is\n    // stricter and makes sure all attributes are properly escaped, avoiding\n    // cases where the tree might mutate when parsed again later due to the\n    // complexities of the HTML parsing algorithm\n    let serializedNewTree = new XMLSerializer().serializeToString(temporaryRoot);\n    // We remove the outer most element as this is the span node created as\n    // the root for the sanitized tree and contains a spurious xmlns attribute\n    // from the XML serialization step.\n    serializedNewTree = serializedNewTree.slice(serializedNewTree.indexOf('>') + 1, serializedNewTree.lastIndexOf('</'));\n    return createHtmlInternal(serializedNewTree);\n}\n/**\n * Serializes a Node into it's HTML representation.\n *\n * Note: this method uses strict XML serialization to mitigate mutation issues\n * when the html is then re-parsed by the browser.\n */\nexport function nodeToHtml(node) {\n    const tempRoot = document.createElement('span');\n    return nodeToHtmlInternal(node, tempRoot);\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,kBAAkB,EAAEC,MAAM,EAAEC,UAAU,QAAS,2BAA2B;AACnF,SAASC,iBAAiB,QAAS,mCAAmC;AACtE,SAASC,YAAY,QAAQ,6BAA6B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,UAAUA,CAACC,KAAK,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EAC5C,IAAIN,MAAM,CAACK,KAAK,CAAC,EAAE;IACf,OAAOA,KAAK;EAChB;EACA,IAAIE,iBAAiB,GAAGC,kBAAkB,CAACC,MAAM,CAACJ,KAAK,CAAC,CAAC;EACzD,IAAIC,OAAO,CAACI,cAAc,EAAE;IACxB;IACAH,iBAAiB,GAAGA,iBAAiB,CAACI,OAAO,CAAC,iBAAiB,EAAE,UAAU,CAAC;EAChF;EACA,IAAIL,OAAO,CAACM,gBAAgB,EAAE;IAC1BL,iBAAiB,GAAGA,iBAAiB,CAACI,OAAO,CAAC,eAAe,EAAE,MAAM,CAAC;EAC1E;EACA,IAAIL,OAAO,CAACO,YAAY,EAAE;IACtBN,iBAAiB,GAAGA,iBAAiB,CAACI,OAAO,CAAC,QAAQ,EAAE,yCAAyC,CAAC;EACtG;EACA,OAAOZ,kBAAkB,CAACQ,iBAAiB,CAAC;AAChD;AACA;AACA;AACA;AACA,OAAO,SAASO,YAAYA,CAACC,MAAM,EAAET,OAAO,GAAG,CAAC,CAAC,EAAE;EAC/C,MAAMU,eAAe,GAAGb,YAAY,CAACY,MAAM,CAAC,CAACE,QAAQ,CAAC,CAAC;EACvD,IAAIC,SAAS,GAAG,SAAS;EACzB,IAAIZ,OAAO,CAACa,EAAE,EAAE;IACZD,SAAS,IAAI,QAAQV,kBAAkB,CAACF,OAAO,CAACa,EAAE,CAAC,GAAG;EAC1D;EACA,IAAIb,OAAO,CAACc,KAAK,EAAE;IACfF,SAAS,IAAI,WAAWV,kBAAkB,CAACF,OAAO,CAACc,KAAK,CAAC,GAAG;EAChE;EACA,IAAId,OAAO,CAACe,IAAI,EAAE;IACdH,SAAS,IAAI,UAAUV,kBAAkB,CAACF,OAAO,CAACe,IAAI,CAAC,GAAG;EAC9D;EACA,IAAIf,OAAO,CAACgB,KAAK,EAAE;IACfJ,SAAS,IAAI,QAAQ;EACzB;EACAA,SAAS,IAAI,IAAIF,eAAe,gBAAgB;EAChD,OAAOjB,kBAAkB,CAACmB,SAAS,CAAC;AACxC;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,eAAeA,CAACC,GAAG,EAAElB,OAAO,GAAG,CAAC,CAAC,EAAE;EAC/C,MAAMmB,YAAY,GAAGvB,iBAAiB,CAACsB,GAAG,CAAC,CAACP,QAAQ,CAAC,CAAC;EACtD,IAAIC,SAAS,GAAG,gBAAgBV,kBAAkB,CAACiB,YAAY,CAAC,GAAG;EACnE,IAAInB,OAAO,CAACoB,KAAK,EAAE;IACfR,SAAS,IAAI,QAAQ;EACzB;EACA,IAAIZ,OAAO,CAACqB,aAAa,EAAE;IACvBT,SAAS,IAAI,oBAAoBV,kBAAkB,CAACF,OAAO,CAACqB,aAAa,CAAC,GAAG;EACjF;EACA,IAAIrB,OAAO,CAACgB,KAAK,EAAE;IACfJ,SAAS,IAAI,QAAQ;EACzB;EACA,IAAIZ,OAAO,CAACa,EAAE,EAAE;IACZD,SAAS,IAAI,QAAQV,kBAAkB,CAACF,OAAO,CAACa,EAAE,CAAC,GAAG;EAC1D;EACA,IAAIb,OAAO,CAACc,KAAK,EAAE;IACfF,SAAS,IAAI,WAAWV,kBAAkB,CAACF,OAAO,CAACc,KAAK,CAAC,GAAG;EAChE;EACA,IAAId,OAAO,CAACe,IAAI,EAAE;IACdH,SAAS,IAAI,UAAUV,kBAAkB,CAACF,OAAO,CAACe,IAAI,CAAC,GAAG;EAC9D;EACA,IAAIf,OAAO,CAACsB,WAAW,EAAE;IACrBV,SAAS,IAAI,iBAAiBV,kBAAkB,CAACF,OAAO,CAACsB,WAAW,CAAC,GAAG;EAC5E;EACAV,SAAS,IAAI,iBAAiB;EAC9B,OAAOnB,kBAAkB,CAACmB,SAAS,CAAC;AACxC;AACA;AACA;AACA;AACA,SAASV,kBAAkBA,CAACqB,IAAI,EAAE;EAC9B,MAAMC,OAAO,GAAGD,IAAI,CACflB,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,CACtBA,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,CACrBA,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,CACrBA,OAAO,CAAC,IAAI,EAAE,QAAQ,CAAC,CACvBA,OAAO,CAAC,IAAI,EAAE,QAAQ,CAAC;EAC5B,OAAOmB,OAAO;AAClB;AACA;AACA,OAAO,SAASC,WAAWA,CAACC,KAAK,EAAE;EAC/B,OAAOC,SAAS,CAAC,EAAE,EAAED,KAAK,CAAC;AAC/B;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,SAASA,CAACC,SAAS,EAAEF,KAAK,EAAE;EACxC,MAAMG,aAAa,GAAG/B,UAAU,CAAC8B,SAAS,CAAC;EAC3C,OAAOnC,kBAAkB,CAACiC,KAAK,CAC1BI,GAAG,CAAE/B,KAAK,IAAKJ,UAAU,CAACG,UAAU,CAACC,KAAK,CAAC,CAAC,CAAC,CAC7CgC,IAAI,CAACpC,UAAU,CAACkC,aAAa,CAAC,CAAClB,QAAQ,CAAC,CAAC,CAAC,CAAC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASqB,WAAWA,CAAA,EAAG;EAC1B,OAAOvC,kBAAkB,CAAC,iBAAiB,CAAC;AAChD;AACA;AACA;AACA;AACA;AACA,OAAO,SAASwC,kBAAkBA,CAACC,IAAI,EAAEC,aAAa,EAAE;EACpDA,aAAa,CAACC,WAAW,CAACF,IAAI,CAAC;EAC/B;EACA;EACA;EACA;EACA,IAAIG,iBAAiB,GAAG,IAAIC,aAAa,CAAC,CAAC,CAACC,iBAAiB,CAACJ,aAAa,CAAC;EAC5E;EACA;EACA;EACAE,iBAAiB,GAAGA,iBAAiB,CAACG,KAAK,CAACH,iBAAiB,CAACI,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAEJ,iBAAiB,CAACK,WAAW,CAAC,IAAI,CAAC,CAAC;EACpH,OAAOjD,kBAAkB,CAAC4C,iBAAiB,CAAC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASM,UAAUA,CAACT,IAAI,EAAE;EAC7B,MAAMU,QAAQ,GAAGC,QAAQ,CAACC,aAAa,CAAC,MAAM,CAAC;EAC/C,OAAOb,kBAAkB,CAACC,IAAI,EAAEU,QAAQ,CAAC;AAC7C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}