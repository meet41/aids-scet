{"ast":null,"code":"/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport '../../environment/dev.js';\nimport { pure } from '../../internals/pure.js';\nimport { ensureTokenIsValid, secretToken } from '../../internals/secrets.js';\nimport { nodeToHtmlInternal } from '../html_builders.js';\nimport { restrictivelySanitizeUrl } from '../url_builders.js';\nimport { createInertFragment } from './inert_fragment.js';\nimport { getNodeName, isElement, isText } from './no_clobber.js';\nimport { parseUrl, ResourceUrlPolicyHintsType } from './resource_url_policy.js';\nimport { DEFAULT_SANITIZER_TABLE } from './sanitizer_table/default_sanitizer_table.js';\nimport { AttributePolicyAction } from './sanitizer_table/sanitizer_table.js';\n/** Implementation for `HtmlSanitizer` */\nexport class HtmlSanitizerImpl {\n  constructor(sanitizerTable, token, styleElementSanitizer, styleAttributeSanitizer, resourceUrlPolicy) {\n    this.sanitizerTable = sanitizerTable;\n    this.styleElementSanitizer = styleElementSanitizer;\n    this.styleAttributeSanitizer = styleAttributeSanitizer;\n    this.resourceUrlPolicy = resourceUrlPolicy;\n    this.changes = [];\n    ensureTokenIsValid(token);\n  }\n  sanitizeAssertUnchanged(html) {\n    if (process.env.NODE_ENV !== 'production') {\n      this.changes = [];\n    }\n    const sanitizedHtml = this.sanitize(html);\n    if (process.env.NODE_ENV !== 'production' && this.changes.length !== 0) {\n      throw new Error(`Unexpected change to HTML value as a result of sanitization. ` + `Input: \"${html}\", sanitized output: \"${sanitizedHtml}\"\\n` + `List of changes:${this.changes.join('\\n')}`);\n    }\n    return sanitizedHtml;\n  }\n  sanitize(html) {\n    const inertDocument = document.implementation.createHTMLDocument('');\n    return nodeToHtmlInternal(this.sanitizeToFragmentInternal(html, inertDocument), inertDocument.body);\n  }\n  sanitizeToFragment(html) {\n    const inertDocument = document.implementation.createHTMLDocument('');\n    return this.sanitizeToFragmentInternal(html, inertDocument);\n  }\n  sanitizeToFragmentInternal(html, inertDocument) {\n    const dirtyFragment = createInertFragment(html, inertDocument);\n    const treeWalker = document.createTreeWalker(dirtyFragment, 5 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT */, n => this.nodeFilter(n));\n    // `nextNode` is called so we skip the root `DocumentFragment`.\n    let currentNode = treeWalker.nextNode();\n    // We create a root element to attach all the children of the body to. We\n    // use div as it as a semantic-free, generic container and does not\n    // represent anything. This is removed when we serialize the tree back\n    // into a string.\n    const sanitizedFragment = inertDocument.createDocumentFragment();\n    let sanitizedParent = sanitizedFragment;\n    while (currentNode !== null) {\n      let sanitizedNode;\n      if (isText(currentNode)) {\n        if (this.styleElementSanitizer && sanitizedParent.nodeName === 'STYLE') {\n          // TODO(securitymb): The sanitizer should record a change whenever\n          // any meaningful change is made to the stylesheet.\n          const sanitizedCss = this.styleElementSanitizer(currentNode.data);\n          sanitizedNode = this.createTextNode(sanitizedCss);\n        } else {\n          sanitizedNode = this.sanitizeTextNode(currentNode);\n        }\n      } else if (isElement(currentNode)) {\n        sanitizedNode = this.sanitizeElementNode(currentNode, inertDocument);\n      } else {\n        let message = '';\n        if (process.env.NODE_ENV !== 'production') {\n          message = 'Node is not of type text or element';\n        }\n        throw new Error(message);\n      }\n      sanitizedParent.appendChild(sanitizedNode);\n      // Advance iterator while keeping track of the sanitized parent for the\n      // current node\n      currentNode = treeWalker.firstChild();\n      if (currentNode) {\n        sanitizedParent = sanitizedNode;\n      } else {\n        while (!(currentNode = treeWalker.nextSibling())) {\n          if (!(currentNode = treeWalker.parentNode())) {\n            break;\n          }\n          sanitizedParent = sanitizedParent.parentNode;\n        }\n      }\n    }\n    return sanitizedFragment;\n  }\n  createTextNode(text) {\n    return document.createTextNode(text);\n  }\n  sanitizeTextNode(textNode) {\n    return this.createTextNode(textNode.data);\n  }\n  sanitizeElementNode(elementNode, inertDocument) {\n    const elementName = getNodeName(elementNode);\n    const newNode = inertDocument.createElement(elementName);\n    const dirtyAttributes = elementNode.attributes;\n    for (const {\n      name,\n      value\n    } of dirtyAttributes) {\n      const policy = this.sanitizerTable.getAttributePolicy(name, elementName);\n      if (!this.satisfiesAllConditions(policy.conditions, dirtyAttributes)) {\n        this.recordChange(`Not all conditions satisfied for attribute: ${name}.`);\n        continue;\n      }\n      switch (policy.policyAction) {\n        case AttributePolicyAction.KEEP:\n          setAttribute(newNode, name, value);\n          break;\n        case AttributePolicyAction.KEEP_AND_SANITIZE_URL:\n          const sanitizedAttrUrl = restrictivelySanitizeUrl(value);\n          if (sanitizedAttrUrl !== value) {\n            this.recordChange(`Url in attribute ${name} was modified during sanitization. Original url:\"${value}\" was sanitized to: \"${sanitizedAttrUrl}\"`);\n          }\n          setAttribute(newNode, name, sanitizedAttrUrl);\n          break;\n        case AttributePolicyAction.KEEP_AND_NORMALIZE:\n          // We don't consider changing the case of an attribute value to be a\n          // semantic change\n          setAttribute(newNode, name, value.toLowerCase());\n          break;\n        case AttributePolicyAction.KEEP_AND_SANITIZE_STYLE:\n          if (this.styleAttributeSanitizer) {\n            const sanitizedCss = this.styleAttributeSanitizer(value);\n            // TODO(securitymb): The sanitizer should record a change whenever\n            // any meaningful change is made to the stylesheet.\n            setAttribute(newNode, name, sanitizedCss);\n          } else {\n            setAttribute(newNode, name, value);\n          }\n          break;\n        case AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY:\n          if (this.resourceUrlPolicy) {\n            const hints = {\n              type: ResourceUrlPolicyHintsType.HTML_ATTRIBUTE,\n              attributeName: name,\n              tagName: elementName\n            };\n            const url = parseUrl(value);\n            const sanitizedUrl = this.resourceUrlPolicy(url, hints);\n            // TODO(securitymb): A change should be recorded if the resource url\n            // changes the URL.\n            if (sanitizedUrl) {\n              setAttribute(newNode, name, sanitizedUrl.toString());\n            }\n            // If null is returned, the attribute is dropped.\n          } else {\n            // If the resource url policy is not set, we allow all resources.\n            // This is how the sanitizer behaved before the resource url policy\n            // was introduced.\n            setAttribute(newNode, name, value);\n          }\n          break;\n        case AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY_FOR_SRCSET:\n          if (this.resourceUrlPolicy) {\n            const hints = {\n              type: ResourceUrlPolicyHintsType.HTML_ATTRIBUTE,\n              attributeName: name,\n              tagName: elementName\n            };\n            const srcset = parseSrcset(value);\n            const sanitizedSrcset = {\n              parts: []\n            };\n            for (const part of srcset.parts) {\n              const url = parseUrl(part.url);\n              const sanitizedUrl = this.resourceUrlPolicy(url, hints);\n              if (sanitizedUrl) {\n                sanitizedSrcset.parts.push({\n                  url: sanitizedUrl.toString(),\n                  descriptor: part.descriptor\n                });\n              }\n            }\n            setAttribute(newNode, name, serializeSrcset(sanitizedSrcset));\n          } else {\n            // If the resource url policy is not set, we allow all resources.\n            // This is how the sanitizer behaved before the resource url\n            // policy was introduced.\n            setAttribute(newNode, name, value);\n          }\n          break;\n        case AttributePolicyAction.DROP:\n          this.recordChange(`Attribute: ${name} was dropped`);\n          break;\n        default:\n          if (process.env.NODE_ENV !== 'production') {\n            checkExhaustive(policy.policyAction, 'Unhandled AttributePolicyAction case');\n          }\n      }\n    }\n    return newNode;\n  }\n  nodeFilter(node) {\n    if (isText(node)) {\n      return 1; // NodeFilter.FILTER_ACCEPT\n    } else if (!isElement(node)) {\n      // Getting a node that is neither an `Element` or a `Text` node. This is\n      // likely due to something that is not supposed to be an element in user\n      // code but recognized as such by the TreeWalker (e.g. a polyfill for\n      // other kind of nodes). Since we can't recognize it as an element, we\n      // drop the node, but we don't record it as a meaningful change.\n      return 2; // NodeFilter.FILTER_REJECT\n    }\n    const nodeName = getNodeName(node);\n    if (nodeName === null) {\n      this.recordChange(`Node name was null for node: ${node}`);\n      return 2; // NodeFilter.FILTER_REJECT\n    }\n    if (this.sanitizerTable.isAllowedElement(nodeName)) {\n      return 1; // NodeFilter.FILTER_ACCEPT\n    }\n    this.recordChange(`Element: ${nodeName} was dropped`);\n    return 2; // NodeFilter.FILTER_REJECT\n  }\n  recordChange(errorMessage) {\n    if (process.env.NODE_ENV !== 'production') {\n      this.changes.push(errorMessage);\n    }\n  }\n  satisfiesAllConditions(conditions, attrs) {\n    var _a;\n    if (!conditions) {\n      return true;\n    }\n    for (const [attrName, expectedValues] of conditions) {\n      const value = (_a = attrs.getNamedItem(attrName)) === null || _a === void 0 ? void 0 : _a.value;\n      if (value && !expectedValues.has(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n/** @noinline Helper to save on codesize. */\nfunction setAttribute(el, name, value) {\n  el.setAttribute(name, value);\n}\n/**\n * Parses a srcset attribute into a structured representation.\n *\n * @param srcset The srcset attribute value.\n * @return The parsed srcset.\n */\nexport function parseSrcset(srcset) {\n  // The algorithm is described in the spec at\n  // https://html.spec.whatwg.org/multipage/images.html#srcset-attributes.\n  //\n  // The code below is greatly simplified though; we don't check the validity of\n  // the descriptors, only extract them. If they happen to be invalid, the\n  // browser will ignore them anyway.\n  const parts = [];\n  for (const part of srcset.split(',')) {\n    const [url, descriptor] = part.trim().split(/\\s+/, 2);\n    parts.push({\n      url,\n      descriptor\n    });\n  }\n  return {\n    parts\n  };\n}\n/**\n * Serializes a srcset into a string.\n *\n * @param srcset The srcset to serialize.\n * @return The serialized srcset.\n */\nexport function serializeSrcset(srcset) {\n  return srcset.parts.map(part => {\n    const {\n      url,\n      descriptor\n    } = part;\n    return `${url}${descriptor ? ` ${descriptor}` : ''}`;\n  })\n  // We always add whitespaces around the parts to remove the ambiguity of\n  // whether a comma character is a part of the URL or not.\n  .join(' , ');\n}\nconst defaultHtmlSanitizer = /* #__PURE__ */pure(() => new HtmlSanitizerImpl(DEFAULT_SANITIZER_TABLE, secretToken));\n/** Sanitizes untrusted html using the default sanitizer configuration. */\nexport function sanitizeHtml(html) {\n  return defaultHtmlSanitizer.sanitize(html);\n}\n/**\n * Sanitizes untrusted html using the default sanitizer configuration. Throws\n * an error if the html was changed.\n */\nexport function sanitizeHtmlAssertUnchanged(html) {\n  return defaultHtmlSanitizer.sanitizeAssertUnchanged(html);\n}\n/**\n * Sanitizes untrusted html using the default sanitizer configuration. Throws\n * an error if the html was changed.\n */\nexport function sanitizeHtmlToFragment(html) {\n  return defaultHtmlSanitizer.sanitizeToFragment(html);\n}\nfunction checkExhaustive(value, msg = `unexpected value ${value}!`) {\n  throw new Error(msg);\n}","map":{"version":3,"names":["pure","ensureTokenIsValid","secretToken","nodeToHtmlInternal","restrictivelySanitizeUrl","createInertFragment","getNodeName","isElement","isText","parseUrl","ResourceUrlPolicyHintsType","DEFAULT_SANITIZER_TABLE","AttributePolicyAction","HtmlSanitizerImpl","constructor","sanitizerTable","token","styleElementSanitizer","styleAttributeSanitizer","resourceUrlPolicy","changes","sanitizeAssertUnchanged","html","process","env","NODE_ENV","sanitizedHtml","sanitize","length","Error","join","inertDocument","document","implementation","createHTMLDocument","sanitizeToFragmentInternal","body","sanitizeToFragment","dirtyFragment","treeWalker","createTreeWalker","n","nodeFilter","currentNode","nextNode","sanitizedFragment","createDocumentFragment","sanitizedParent","sanitizedNode","nodeName","sanitizedCss","data","createTextNode","sanitizeTextNode","sanitizeElementNode","message","appendChild","firstChild","nextSibling","parentNode","text","textNode","elementNode","elementName","newNode","createElement","dirtyAttributes","attributes","name","value","policy","getAttributePolicy","satisfiesAllConditions","conditions","recordChange","policyAction","KEEP","setAttribute","KEEP_AND_SANITIZE_URL","sanitizedAttrUrl","KEEP_AND_NORMALIZE","toLowerCase","KEEP_AND_SANITIZE_STYLE","KEEP_AND_USE_RESOURCE_URL_POLICY","hints","type","HTML_ATTRIBUTE","attributeName","tagName","url","sanitizedUrl","toString","KEEP_AND_USE_RESOURCE_URL_POLICY_FOR_SRCSET","srcset","parseSrcset","sanitizedSrcset","parts","part","push","descriptor","serializeSrcset","DROP","checkExhaustive","node","isAllowedElement","errorMessage","attrs","_a","attrName","expectedValues","getNamedItem","has","el","split","trim","map","defaultHtmlSanitizer","sanitizeHtml","sanitizeHtmlAssertUnchanged","sanitizeHtmlToFragment","msg"],"sources":["E:/HTML/Udemy_Full Stack Web/AI-SCET Website/aiscet/node_modules/safevalues/dist/mjs/builders/html_sanitizer/html_sanitizer.js"],"sourcesContent":["/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport '../../environment/dev.js';\nimport { pure } from '../../internals/pure.js';\nimport { ensureTokenIsValid, secretToken } from '../../internals/secrets.js';\nimport { nodeToHtmlInternal } from '../html_builders.js';\nimport { restrictivelySanitizeUrl } from '../url_builders.js';\nimport { createInertFragment } from './inert_fragment.js';\nimport { getNodeName, isElement, isText } from './no_clobber.js';\nimport { parseUrl, ResourceUrlPolicyHintsType, } from './resource_url_policy.js';\nimport { DEFAULT_SANITIZER_TABLE } from './sanitizer_table/default_sanitizer_table.js';\nimport { AttributePolicyAction, } from './sanitizer_table/sanitizer_table.js';\n/** Implementation for `HtmlSanitizer` */\nexport class HtmlSanitizerImpl {\n    constructor(sanitizerTable, token, styleElementSanitizer, styleAttributeSanitizer, resourceUrlPolicy) {\n        this.sanitizerTable = sanitizerTable;\n        this.styleElementSanitizer = styleElementSanitizer;\n        this.styleAttributeSanitizer = styleAttributeSanitizer;\n        this.resourceUrlPolicy = resourceUrlPolicy;\n        this.changes = [];\n        ensureTokenIsValid(token);\n    }\n    sanitizeAssertUnchanged(html) {\n        if (process.env.NODE_ENV !== 'production') {\n            this.changes = [];\n        }\n        const sanitizedHtml = this.sanitize(html);\n        if (process.env.NODE_ENV !== 'production' && this.changes.length !== 0) {\n            throw new Error(`Unexpected change to HTML value as a result of sanitization. ` +\n                `Input: \"${html}\", sanitized output: \"${sanitizedHtml}\"\\n` +\n                `List of changes:${this.changes.join('\\n')}`);\n        }\n        return sanitizedHtml;\n    }\n    sanitize(html) {\n        const inertDocument = document.implementation.createHTMLDocument('');\n        return nodeToHtmlInternal(this.sanitizeToFragmentInternal(html, inertDocument), inertDocument.body);\n    }\n    sanitizeToFragment(html) {\n        const inertDocument = document.implementation.createHTMLDocument('');\n        return this.sanitizeToFragmentInternal(html, inertDocument);\n    }\n    sanitizeToFragmentInternal(html, inertDocument) {\n        const dirtyFragment = createInertFragment(html, inertDocument);\n        const treeWalker = document.createTreeWalker(dirtyFragment, 5 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT */, (n) => this.nodeFilter(n));\n        // `nextNode` is called so we skip the root `DocumentFragment`.\n        let currentNode = treeWalker.nextNode();\n        // We create a root element to attach all the children of the body to. We\n        // use div as it as a semantic-free, generic container and does not\n        // represent anything. This is removed when we serialize the tree back\n        // into a string.\n        const sanitizedFragment = inertDocument.createDocumentFragment();\n        let sanitizedParent = sanitizedFragment;\n        while (currentNode !== null) {\n            let sanitizedNode;\n            if (isText(currentNode)) {\n                if (this.styleElementSanitizer &&\n                    sanitizedParent.nodeName === 'STYLE') {\n                    // TODO(securitymb): The sanitizer should record a change whenever\n                    // any meaningful change is made to the stylesheet.\n                    const sanitizedCss = this.styleElementSanitizer(currentNode.data);\n                    sanitizedNode = this.createTextNode(sanitizedCss);\n                }\n                else {\n                    sanitizedNode = this.sanitizeTextNode(currentNode);\n                }\n            }\n            else if (isElement(currentNode)) {\n                sanitizedNode = this.sanitizeElementNode(currentNode, inertDocument);\n            }\n            else {\n                let message = '';\n                if (process.env.NODE_ENV !== 'production') {\n                    message = 'Node is not of type text or element';\n                }\n                throw new Error(message);\n            }\n            sanitizedParent.appendChild(sanitizedNode);\n            // Advance iterator while keeping track of the sanitized parent for the\n            // current node\n            currentNode = treeWalker.firstChild();\n            if (currentNode) {\n                sanitizedParent = sanitizedNode;\n            }\n            else {\n                while (!(currentNode = treeWalker.nextSibling())) {\n                    if (!(currentNode = treeWalker.parentNode())) {\n                        break;\n                    }\n                    sanitizedParent = sanitizedParent.parentNode;\n                }\n            }\n        }\n        return sanitizedFragment;\n    }\n    createTextNode(text) {\n        return document.createTextNode(text);\n    }\n    sanitizeTextNode(textNode) {\n        return this.createTextNode(textNode.data);\n    }\n    sanitizeElementNode(elementNode, inertDocument) {\n        const elementName = getNodeName(elementNode);\n        const newNode = inertDocument.createElement(elementName);\n        const dirtyAttributes = elementNode.attributes;\n        for (const { name, value } of dirtyAttributes) {\n            const policy = this.sanitizerTable.getAttributePolicy(name, elementName);\n            if (!this.satisfiesAllConditions(policy.conditions, dirtyAttributes)) {\n                this.recordChange(`Not all conditions satisfied for attribute: ${name}.`);\n                continue;\n            }\n            switch (policy.policyAction) {\n                case AttributePolicyAction.KEEP:\n                    setAttribute(newNode, name, value);\n                    break;\n                case AttributePolicyAction.KEEP_AND_SANITIZE_URL:\n                    const sanitizedAttrUrl = restrictivelySanitizeUrl(value);\n                    if (sanitizedAttrUrl !== value) {\n                        this.recordChange(`Url in attribute ${name} was modified during sanitization. Original url:\"${value}\" was sanitized to: \"${sanitizedAttrUrl}\"`);\n                    }\n                    setAttribute(newNode, name, sanitizedAttrUrl);\n                    break;\n                case AttributePolicyAction.KEEP_AND_NORMALIZE:\n                    // We don't consider changing the case of an attribute value to be a\n                    // semantic change\n                    setAttribute(newNode, name, value.toLowerCase());\n                    break;\n                case AttributePolicyAction.KEEP_AND_SANITIZE_STYLE:\n                    if (this.styleAttributeSanitizer) {\n                        const sanitizedCss = this.styleAttributeSanitizer(value);\n                        // TODO(securitymb): The sanitizer should record a change whenever\n                        // any meaningful change is made to the stylesheet.\n                        setAttribute(newNode, name, sanitizedCss);\n                    }\n                    else {\n                        setAttribute(newNode, name, value);\n                    }\n                    break;\n                case AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY:\n                    if (this.resourceUrlPolicy) {\n                        const hints = {\n                            type: ResourceUrlPolicyHintsType.HTML_ATTRIBUTE,\n                            attributeName: name,\n                            tagName: elementName,\n                        };\n                        const url = parseUrl(value);\n                        const sanitizedUrl = this.resourceUrlPolicy(url, hints);\n                        // TODO(securitymb): A change should be recorded if the resource url\n                        // changes the URL.\n                        if (sanitizedUrl) {\n                            setAttribute(newNode, name, sanitizedUrl.toString());\n                        }\n                        // If null is returned, the attribute is dropped.\n                    }\n                    else {\n                        // If the resource url policy is not set, we allow all resources.\n                        // This is how the sanitizer behaved before the resource url policy\n                        // was introduced.\n                        setAttribute(newNode, name, value);\n                    }\n                    break;\n                case AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY_FOR_SRCSET:\n                    if (this.resourceUrlPolicy) {\n                        const hints = {\n                            type: ResourceUrlPolicyHintsType.HTML_ATTRIBUTE,\n                            attributeName: name,\n                            tagName: elementName,\n                        };\n                        const srcset = parseSrcset(value);\n                        const sanitizedSrcset = { parts: [] };\n                        for (const part of srcset.parts) {\n                            const url = parseUrl(part.url);\n                            const sanitizedUrl = this.resourceUrlPolicy(url, hints);\n                            if (sanitizedUrl) {\n                                sanitizedSrcset.parts.push({\n                                    url: sanitizedUrl.toString(),\n                                    descriptor: part.descriptor,\n                                });\n                            }\n                        }\n                        setAttribute(newNode, name, serializeSrcset(sanitizedSrcset));\n                    }\n                    else {\n                        // If the resource url policy is not set, we allow all resources.\n                        // This is how the sanitizer behaved before the resource url\n                        // policy was introduced.\n                        setAttribute(newNode, name, value);\n                    }\n                    break;\n                case AttributePolicyAction.DROP:\n                    this.recordChange(`Attribute: ${name} was dropped`);\n                    break;\n                default:\n                    if (process.env.NODE_ENV !== 'production') {\n                        checkExhaustive(policy.policyAction, 'Unhandled AttributePolicyAction case');\n                    }\n            }\n        }\n        return newNode;\n    }\n    nodeFilter(node) {\n        if (isText(node)) {\n            return 1; // NodeFilter.FILTER_ACCEPT\n        }\n        else if (!isElement(node)) {\n            // Getting a node that is neither an `Element` or a `Text` node. This is\n            // likely due to something that is not supposed to be an element in user\n            // code but recognized as such by the TreeWalker (e.g. a polyfill for\n            // other kind of nodes). Since we can't recognize it as an element, we\n            // drop the node, but we don't record it as a meaningful change.\n            return 2; // NodeFilter.FILTER_REJECT\n        }\n        const nodeName = getNodeName(node);\n        if (nodeName === null) {\n            this.recordChange(`Node name was null for node: ${node}`);\n            return 2; // NodeFilter.FILTER_REJECT\n        }\n        if (this.sanitizerTable.isAllowedElement(nodeName)) {\n            return 1; // NodeFilter.FILTER_ACCEPT\n        }\n        this.recordChange(`Element: ${nodeName} was dropped`);\n        return 2; // NodeFilter.FILTER_REJECT\n    }\n    recordChange(errorMessage) {\n        if (process.env.NODE_ENV !== 'production') {\n            this.changes.push(errorMessage);\n        }\n    }\n    satisfiesAllConditions(conditions, attrs) {\n        var _a;\n        if (!conditions) {\n            return true;\n        }\n        for (const [attrName, expectedValues] of conditions) {\n            const value = (_a = attrs.getNamedItem(attrName)) === null || _a === void 0 ? void 0 : _a.value;\n            if (value && !expectedValues.has(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n/** @noinline Helper to save on codesize. */\nfunction setAttribute(el, name, value) {\n    el.setAttribute(name, value);\n}\n/**\n * Parses a srcset attribute into a structured representation.\n *\n * @param srcset The srcset attribute value.\n * @return The parsed srcset.\n */\nexport function parseSrcset(srcset) {\n    // The algorithm is described in the spec at\n    // https://html.spec.whatwg.org/multipage/images.html#srcset-attributes.\n    //\n    // The code below is greatly simplified though; we don't check the validity of\n    // the descriptors, only extract them. If they happen to be invalid, the\n    // browser will ignore them anyway.\n    const parts = [];\n    for (const part of srcset.split(',')) {\n        const [url, descriptor] = part.trim().split(/\\s+/, 2);\n        parts.push({ url, descriptor });\n    }\n    return { parts };\n}\n/**\n * Serializes a srcset into a string.\n *\n * @param srcset The srcset to serialize.\n * @return The serialized srcset.\n */\nexport function serializeSrcset(srcset) {\n    return (srcset.parts\n        .map((part) => {\n        const { url, descriptor } = part;\n        return `${url}${descriptor ? ` ${descriptor}` : ''}`;\n    })\n        // We always add whitespaces around the parts to remove the ambiguity of\n        // whether a comma character is a part of the URL or not.\n        .join(' , '));\n}\nconst defaultHtmlSanitizer = /* #__PURE__ */ pure(() => new HtmlSanitizerImpl(DEFAULT_SANITIZER_TABLE, secretToken));\n/** Sanitizes untrusted html using the default sanitizer configuration. */\nexport function sanitizeHtml(html) {\n    return defaultHtmlSanitizer.sanitize(html);\n}\n/**\n * Sanitizes untrusted html using the default sanitizer configuration. Throws\n * an error if the html was changed.\n */\nexport function sanitizeHtmlAssertUnchanged(html) {\n    return defaultHtmlSanitizer.sanitizeAssertUnchanged(html);\n}\n/**\n * Sanitizes untrusted html using the default sanitizer configuration. Throws\n * an error if the html was changed.\n */\nexport function sanitizeHtmlToFragment(html) {\n    return defaultHtmlSanitizer.sanitizeToFragment(html);\n}\nfunction checkExhaustive(value, msg = `unexpected value ${value}!`) {\n    throw new Error(msg);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}