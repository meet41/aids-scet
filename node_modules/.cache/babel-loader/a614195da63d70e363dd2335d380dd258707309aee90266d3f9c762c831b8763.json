{"ast":null,"code":"import { useState, useReducer, useContext, useRef, useCallback, useEffect, useMemo } from 'react';\nimport { flushSync } from 'react-dom';\nimport { MenuContainer } from './MenuContainer.js';\nimport { jsxs, jsx } from 'react/jsx-runtime';\nimport { createSubmenuCtx } from '../utils/submenuCtx.js';\nimport { SettingsContext, MenuListContext, HoverActionTypes, menuClass, menuArrowClass, positionAbsolute, dummyItemProps, MenuListItemContext, HoverItemContext, Keys, CloseReason, FocusPositions } from '../utils/constants.js';\nimport { useItems } from '../hooks/useItems.js';\nimport { getScrollAncestor, floatEqual, commonProps, mergeProps, safeCall, isMenuOpen, getTransition, batchedUpdates } from '../utils/utils.js';\nimport { getPositionHelpers } from '../positionUtils/getPositionHelpers.js';\nimport { positionMenu } from '../positionUtils/positionMenu.js';\nimport { useLayoutEffect as useIsomorphicLayoutEffect } from '../hooks/useIsomorphicLayoutEffect.js';\nimport { useBEM } from '../hooks/useBEM.js';\nimport { useCombinedRef } from '../hooks/useCombinedRef.js';\nconst offScreen = -9999;\nconst MenuList = ({\n  ariaLabel,\n  menuClassName,\n  menuStyle,\n  arrow,\n  arrowProps = {},\n  anchorPoint,\n  anchorRef,\n  containerRef,\n  containerProps,\n  focusProps,\n  externalRef,\n  parentScrollingRef,\n  align = 'start',\n  direction = 'bottom',\n  position = 'auto',\n  overflow = 'visible',\n  setDownOverflow,\n  repositionFlag,\n  captureFocus = true,\n  state,\n  endTransition,\n  isDisabled,\n  menuItemFocus,\n  gap = 0,\n  shift = 0,\n  children,\n  onClose,\n  ...restProps\n}) => {\n  const [menuPosition, setMenuPosition] = useState({\n    x: offScreen,\n    y: offScreen\n  });\n  const [arrowPosition, setArrowPosition] = useState({});\n  const [overflowData, setOverflowData] = useState();\n  const [expandedDirection, setExpandedDirection] = useState(direction);\n  const [submenuCtx] = useState(createSubmenuCtx);\n  const [reposSubmenu, forceReposSubmenu] = useReducer(c => c + 1, 1);\n  const {\n    transition,\n    boundingBoxRef,\n    boundingBoxPadding,\n    rootMenuRef,\n    rootAnchorRef,\n    scrollNodesRef,\n    reposition,\n    viewScroll,\n    submenuCloseDelay\n  } = useContext(SettingsContext);\n  const {\n    submenuCtx: parentSubmenuCtx,\n    reposSubmenu: reposFlag = repositionFlag\n  } = useContext(MenuListContext);\n  const menuRef = useRef(null);\n  const focusRef = useRef();\n  const arrowRef = useRef();\n  const prevOpen = useRef(false);\n  const latestMenuSize = useRef({\n    width: 0,\n    height: 0\n  });\n  const latestHandlePosition = useRef(() => {});\n  const {\n    hoverItem,\n    dispatch,\n    updateItems\n  } = useItems(menuRef, focusRef);\n  const isOpen = isMenuOpen(state);\n  const openTransition = getTransition(transition, 'open');\n  const closeTransition = getTransition(transition, 'close');\n  const scrollNodes = scrollNodesRef.current;\n  const onKeyDown = e => {\n    switch (e.key) {\n      case Keys.HOME:\n        dispatch(HoverActionTypes.FIRST);\n        break;\n      case Keys.END:\n        dispatch(HoverActionTypes.LAST);\n        break;\n      case Keys.UP:\n        dispatch(HoverActionTypes.DECREASE, hoverItem);\n        break;\n      case Keys.DOWN:\n        dispatch(HoverActionTypes.INCREASE, hoverItem);\n        break;\n      case Keys.SPACE:\n        if (e.target && e.target.className.indexOf(menuClass) !== -1) {\n          e.preventDefault();\n        }\n        return;\n      default:\n        return;\n    }\n    e.preventDefault();\n    e.stopPropagation();\n  };\n  const onAnimationEnd = () => {\n    if (state === 'closing') {\n      setOverflowData();\n    }\n    safeCall(endTransition);\n  };\n  const onPointerMove = e => {\n    e.stopPropagation();\n    submenuCtx.on(submenuCloseDelay, () => {\n      dispatch(HoverActionTypes.RESET);\n      focusRef.current.focus();\n    });\n  };\n  const onPointerLeave = e => {\n    if (e.target === e.currentTarget) submenuCtx.off();\n  };\n  const handlePosition = useCallback(noOverflowCheck => {\n    var _anchorRef$current;\n    const anchorRect = anchorRef ? (_anchorRef$current = anchorRef.current) == null ? void 0 : _anchorRef$current.getBoundingClientRect() : anchorPoint ? {\n      left: anchorPoint.x,\n      right: anchorPoint.x,\n      top: anchorPoint.y,\n      bottom: anchorPoint.y,\n      width: 0,\n      height: 0\n    } : null;\n    if (!anchorRect) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn('[React-Menu] Menu might not be positioned properly as one of the anchorRef or anchorPoint prop should be provided. If `anchorRef` is provided, the anchor must be mounted before menu is open.');\n      }\n      return;\n    }\n    if (!scrollNodes.menu) {\n      scrollNodes.menu = (boundingBoxRef ? boundingBoxRef.current : getScrollAncestor(rootMenuRef.current)) || window;\n    }\n    const positionHelpers = getPositionHelpers(containerRef, menuRef, scrollNodes.menu, boundingBoxPadding);\n    let {\n      arrowX,\n      arrowY,\n      x,\n      y,\n      computedDirection\n    } = positionMenu({\n      arrow,\n      align,\n      direction,\n      gap,\n      shift,\n      position,\n      anchorRect,\n      arrowRef,\n      positionHelpers\n    });\n    const {\n      menuRect\n    } = positionHelpers;\n    let menuHeight = menuRect.height;\n    if (!noOverflowCheck && overflow !== 'visible') {\n      const {\n        getTopOverflow,\n        getBottomOverflow\n      } = positionHelpers;\n      let height, overflowAmt;\n      const prevHeight = latestMenuSize.current.height;\n      const bottomOverflow = getBottomOverflow(y);\n      if (bottomOverflow > 0 || floatEqual(bottomOverflow, 0) && floatEqual(menuHeight, prevHeight)) {\n        height = menuHeight - bottomOverflow;\n        overflowAmt = bottomOverflow;\n      } else {\n        const topOverflow = getTopOverflow(y);\n        if (topOverflow < 0 || floatEqual(topOverflow, 0) && floatEqual(menuHeight, prevHeight)) {\n          height = menuHeight + topOverflow;\n          overflowAmt = 0 - topOverflow;\n          if (height >= 0) y -= topOverflow;\n        }\n      }\n      if (height >= 0) {\n        menuHeight = height;\n        setOverflowData({\n          height,\n          overflowAmt\n        });\n      } else {\n        setOverflowData();\n      }\n    }\n    if (arrow) setArrowPosition({\n      x: arrowX,\n      y: arrowY\n    });\n    setMenuPosition({\n      x,\n      y\n    });\n    setExpandedDirection(computedDirection);\n    latestMenuSize.current = {\n      width: menuRect.width,\n      height: menuHeight\n    };\n  }, [arrow, align, boundingBoxPadding, direction, gap, shift, position, overflow, anchorPoint, anchorRef, containerRef, boundingBoxRef, rootMenuRef, scrollNodes]);\n  useIsomorphicLayoutEffect(() => {\n    if (isOpen) {\n      handlePosition();\n      if (prevOpen.current) forceReposSubmenu();\n    }\n    prevOpen.current = isOpen;\n    latestHandlePosition.current = handlePosition;\n  }, [isOpen, handlePosition, reposFlag]);\n  useIsomorphicLayoutEffect(() => {\n    if (overflowData && !setDownOverflow) menuRef.current.scrollTop = 0;\n  }, [overflowData, setDownOverflow]);\n  useIsomorphicLayoutEffect(() => updateItems, [updateItems]);\n  useEffect(() => {\n    let {\n      menu: menuScroll\n    } = scrollNodes;\n    if (!isOpen || !menuScroll) return;\n    menuScroll = menuScroll.addEventListener ? menuScroll : window;\n    if (!scrollNodes.anchors) {\n      scrollNodes.anchors = [];\n      let anchorScroll = getScrollAncestor(rootAnchorRef && rootAnchorRef.current);\n      while (anchorScroll && anchorScroll !== menuScroll) {\n        scrollNodes.anchors.push(anchorScroll);\n        anchorScroll = getScrollAncestor(anchorScroll);\n      }\n    }\n    let scroll = viewScroll;\n    if (scrollNodes.anchors.length && scroll === 'initial') scroll = 'auto';\n    if (scroll === 'initial') return;\n    const handleScroll = () => {\n      if (scroll === 'auto') {\n        batchedUpdates(() => handlePosition(true));\n      } else {\n        safeCall(onClose, {\n          reason: CloseReason.SCROLL\n        });\n      }\n    };\n    const scrollObservers = scrollNodes.anchors.concat(viewScroll !== 'initial' ? menuScroll : []);\n    scrollObservers.forEach(o => o.addEventListener('scroll', handleScroll));\n    return () => scrollObservers.forEach(o => o.removeEventListener('scroll', handleScroll));\n  }, [rootAnchorRef, scrollNodes, isOpen, onClose, viewScroll, handlePosition]);\n  const hasOverflow = !!overflowData && overflowData.overflowAmt > 0;\n  useEffect(() => {\n    if (hasOverflow || !isOpen || !parentScrollingRef) return;\n    const handleScroll = () => batchedUpdates(handlePosition);\n    const parentScroll = parentScrollingRef.current;\n    parentScroll.addEventListener('scroll', handleScroll);\n    return () => parentScroll.removeEventListener('scroll', handleScroll);\n  }, [isOpen, hasOverflow, parentScrollingRef, handlePosition]);\n  useEffect(() => {\n    if (typeof ResizeObserver !== 'function' || reposition === 'initial') return;\n    const resizeObserver = new ResizeObserver(([entry]) => {\n      const {\n        borderBoxSize,\n        target\n      } = entry;\n      let width, height;\n      if (borderBoxSize) {\n        const {\n          inlineSize,\n          blockSize\n        } = borderBoxSize[0] || borderBoxSize;\n        width = inlineSize;\n        height = blockSize;\n      } else {\n        const borderRect = target.getBoundingClientRect();\n        width = borderRect.width;\n        height = borderRect.height;\n      }\n      if (width === 0 || height === 0) return;\n      if (floatEqual(width, latestMenuSize.current.width, 1) && floatEqual(height, latestMenuSize.current.height, 1)) return;\n      flushSync(() => {\n        latestHandlePosition.current();\n        forceReposSubmenu();\n      });\n    });\n    const observeTarget = menuRef.current;\n    resizeObserver.observe(observeTarget, {\n      box: 'border-box'\n    });\n    return () => resizeObserver.unobserve(observeTarget);\n  }, [reposition]);\n  useEffect(() => {\n    if (!isOpen) {\n      dispatch(HoverActionTypes.RESET);\n      if (!closeTransition) setOverflowData();\n      return;\n    }\n    const {\n      position,\n      alwaysUpdate\n    } = menuItemFocus || {};\n    const setItemFocus = () => {\n      if (position === FocusPositions.FIRST) {\n        dispatch(HoverActionTypes.FIRST);\n      } else if (position === FocusPositions.LAST) {\n        dispatch(HoverActionTypes.LAST);\n      } else if (position >= -1) {\n        dispatch(HoverActionTypes.SET_INDEX, undefined, position);\n      }\n    };\n    if (alwaysUpdate) {\n      setItemFocus();\n    } else if (captureFocus) {\n      const id = setTimeout(() => {\n        const menuElt = menuRef.current;\n        if (menuElt && !menuElt.contains(document.activeElement)) {\n          focusRef.current.focus();\n          setItemFocus();\n        }\n      }, openTransition ? 170 : 100);\n      return () => clearTimeout(id);\n    }\n  }, [isOpen, openTransition, closeTransition, captureFocus, menuItemFocus, dispatch]);\n  const itemContext = useMemo(() => ({\n    isParentOpen: isOpen,\n    submenuCtx,\n    dispatch,\n    updateItems\n  }), [isOpen, submenuCtx, dispatch, updateItems]);\n  let maxHeight, overflowAmt;\n  if (overflowData) {\n    setDownOverflow ? overflowAmt = overflowData.overflowAmt : maxHeight = overflowData.height;\n  }\n  const listContext = useMemo(() => ({\n    reposSubmenu,\n    submenuCtx,\n    overflow,\n    overflowAmt,\n    parentMenuRef: menuRef,\n    parentDir: expandedDirection\n  }), [reposSubmenu, submenuCtx, overflow, overflowAmt, expandedDirection]);\n  const overflowStyle = maxHeight >= 0 ? {\n    maxHeight,\n    overflow\n  } : undefined;\n  const modifiers = useMemo(() => ({\n    state,\n    dir: expandedDirection\n  }), [state, expandedDirection]);\n  const arrowModifiers = useMemo(() => ({\n    dir: expandedDirection\n  }), [expandedDirection]);\n  const _arrowClassName = useBEM({\n    block: menuClass,\n    element: menuArrowClass,\n    modifiers: arrowModifiers,\n    className: arrowProps.className\n  });\n  const menu = /*#__PURE__*/jsxs(\"ul\", {\n    role: \"menu\",\n    \"aria-label\": ariaLabel,\n    ...commonProps(isDisabled),\n    ...mergeProps({\n      onPointerEnter: parentSubmenuCtx == null ? void 0 : parentSubmenuCtx.off,\n      onPointerMove,\n      onPointerLeave,\n      onKeyDown,\n      onAnimationEnd\n    }, restProps),\n    ref: useCombinedRef(externalRef, menuRef),\n    className: useBEM({\n      block: menuClass,\n      modifiers,\n      className: menuClassName\n    }),\n    style: {\n      ...menuStyle,\n      ...overflowStyle,\n      margin: 0,\n      display: state === 'closed' ? 'none' : undefined,\n      position: positionAbsolute,\n      left: menuPosition.x,\n      top: menuPosition.y\n    },\n    children: [/*#__PURE__*/jsx(\"li\", {\n      tabIndex: -1,\n      style: {\n        position: positionAbsolute,\n        left: 0,\n        top: 0,\n        display: 'block',\n        outline: 'none'\n      },\n      ref: focusRef,\n      ...dummyItemProps,\n      ...focusProps\n    }), arrow && /*#__PURE__*/jsx(\"li\", {\n      ...dummyItemProps,\n      ...arrowProps,\n      className: _arrowClassName,\n      style: {\n        display: 'block',\n        position: positionAbsolute,\n        left: arrowPosition.x,\n        top: arrowPosition.y,\n        ...arrowProps.style\n      },\n      ref: arrowRef\n    }), /*#__PURE__*/jsx(MenuListContext.Provider, {\n      value: listContext,\n      children: /*#__PURE__*/jsx(MenuListItemContext.Provider, {\n        value: itemContext,\n        children: /*#__PURE__*/jsx(HoverItemContext.Provider, {\n          value: hoverItem,\n          children: safeCall(children, modifiers)\n        })\n      })\n    })]\n  });\n  return containerProps ? /*#__PURE__*/jsx(MenuContainer, {\n    ...containerProps,\n    isOpen: isOpen,\n    children: menu\n  }) : menu;\n};\nexport { MenuList };","map":{"version":3,"names":["useState","useReducer","useContext","useRef","useCallback","useEffect","useMemo","flushSync","MenuContainer","jsxs","jsx","createSubmenuCtx","SettingsContext","MenuListContext","HoverActionTypes","menuClass","menuArrowClass","positionAbsolute","dummyItemProps","MenuListItemContext","HoverItemContext","Keys","CloseReason","FocusPositions","useItems","getScrollAncestor","floatEqual","commonProps","mergeProps","safeCall","isMenuOpen","getTransition","batchedUpdates","getPositionHelpers","positionMenu","useLayoutEffect","useIsomorphicLayoutEffect","useBEM","useCombinedRef","offScreen","MenuList","ariaLabel","menuClassName","menuStyle","arrow","arrowProps","anchorPoint","anchorRef","containerRef","containerProps","focusProps","externalRef","parentScrollingRef","align","direction","position","overflow","setDownOverflow","repositionFlag","captureFocus","state","endTransition","isDisabled","menuItemFocus","gap","shift","children","onClose","restProps","menuPosition","setMenuPosition","x","y","arrowPosition","setArrowPosition","overflowData","setOverflowData","expandedDirection","setExpandedDirection","submenuCtx","reposSubmenu","forceReposSubmenu","c","transition","boundingBoxRef","boundingBoxPadding","rootMenuRef","rootAnchorRef","scrollNodesRef","reposition","viewScroll","submenuCloseDelay","parentSubmenuCtx","reposFlag","menuRef","focusRef","arrowRef","prevOpen","latestMenuSize","width","height","latestHandlePosition","hoverItem","dispatch","updateItems","isOpen","openTransition","closeTransition","scrollNodes","current","onKeyDown","e","key","HOME","FIRST","END","LAST","UP","DECREASE","DOWN","INCREASE","SPACE","target","className","indexOf","preventDefault","stopPropagation","onAnimationEnd","onPointerMove","on","RESET","focus","onPointerLeave","currentTarget","off","handlePosition","noOverflowCheck","_anchorRef$current","anchorRect","getBoundingClientRect","left","right","top","bottom","process","env","NODE_ENV","console","warn","menu","window","positionHelpers","arrowX","arrowY","computedDirection","menuRect","menuHeight","getTopOverflow","getBottomOverflow","overflowAmt","prevHeight","bottomOverflow","topOverflow","scrollTop","menuScroll","addEventListener","anchors","anchorScroll","push","scroll","length","handleScroll","reason","SCROLL","scrollObservers","concat","forEach","o","removeEventListener","hasOverflow","parentScroll","ResizeObserver","resizeObserver","entry","borderBoxSize","inlineSize","blockSize","borderRect","observeTarget","observe","box","unobserve","alwaysUpdate","setItemFocus","SET_INDEX","undefined","id","setTimeout","menuElt","contains","document","activeElement","clearTimeout","itemContext","isParentOpen","maxHeight","listContext","parentMenuRef","parentDir","overflowStyle","modifiers","dir","arrowModifiers","_arrowClassName","block","element","role","onPointerEnter","ref","style","margin","display","tabIndex","outline","Provider","value"],"sources":["E:/HTML/Udemy_Full Stack Web/AI-SCET Website/aiscet/node_modules/@szhsin/react-menu/dist/es/components/MenuList.js"],"sourcesContent":["import { useState, useReducer, useContext, useRef, useCallback, useEffect, useMemo } from 'react';\nimport { flushSync } from 'react-dom';\nimport { MenuContainer } from './MenuContainer.js';\nimport { jsxs, jsx } from 'react/jsx-runtime';\nimport { createSubmenuCtx } from '../utils/submenuCtx.js';\nimport { SettingsContext, MenuListContext, HoverActionTypes, menuClass, menuArrowClass, positionAbsolute, dummyItemProps, MenuListItemContext, HoverItemContext, Keys, CloseReason, FocusPositions } from '../utils/constants.js';\nimport { useItems } from '../hooks/useItems.js';\nimport { getScrollAncestor, floatEqual, commonProps, mergeProps, safeCall, isMenuOpen, getTransition, batchedUpdates } from '../utils/utils.js';\nimport { getPositionHelpers } from '../positionUtils/getPositionHelpers.js';\nimport { positionMenu } from '../positionUtils/positionMenu.js';\nimport { useLayoutEffect as useIsomorphicLayoutEffect } from '../hooks/useIsomorphicLayoutEffect.js';\nimport { useBEM } from '../hooks/useBEM.js';\nimport { useCombinedRef } from '../hooks/useCombinedRef.js';\n\nconst offScreen = -9999;\nconst MenuList = ({\n  ariaLabel,\n  menuClassName,\n  menuStyle,\n  arrow,\n  arrowProps = {},\n  anchorPoint,\n  anchorRef,\n  containerRef,\n  containerProps,\n  focusProps,\n  externalRef,\n  parentScrollingRef,\n  align = 'start',\n  direction = 'bottom',\n  position = 'auto',\n  overflow = 'visible',\n  setDownOverflow,\n  repositionFlag,\n  captureFocus = true,\n  state,\n  endTransition,\n  isDisabled,\n  menuItemFocus,\n  gap = 0,\n  shift = 0,\n  children,\n  onClose,\n  ...restProps\n}) => {\n  const [menuPosition, setMenuPosition] = useState({\n    x: offScreen,\n    y: offScreen\n  });\n  const [arrowPosition, setArrowPosition] = useState({});\n  const [overflowData, setOverflowData] = useState();\n  const [expandedDirection, setExpandedDirection] = useState(direction);\n  const [submenuCtx] = useState(createSubmenuCtx);\n  const [reposSubmenu, forceReposSubmenu] = useReducer(c => c + 1, 1);\n  const {\n    transition,\n    boundingBoxRef,\n    boundingBoxPadding,\n    rootMenuRef,\n    rootAnchorRef,\n    scrollNodesRef,\n    reposition,\n    viewScroll,\n    submenuCloseDelay\n  } = useContext(SettingsContext);\n  const {\n    submenuCtx: parentSubmenuCtx,\n    reposSubmenu: reposFlag = repositionFlag\n  } = useContext(MenuListContext);\n  const menuRef = useRef(null);\n  const focusRef = useRef();\n  const arrowRef = useRef();\n  const prevOpen = useRef(false);\n  const latestMenuSize = useRef({\n    width: 0,\n    height: 0\n  });\n  const latestHandlePosition = useRef(() => {});\n  const {\n    hoverItem,\n    dispatch,\n    updateItems\n  } = useItems(menuRef, focusRef);\n  const isOpen = isMenuOpen(state);\n  const openTransition = getTransition(transition, 'open');\n  const closeTransition = getTransition(transition, 'close');\n  const scrollNodes = scrollNodesRef.current;\n  const onKeyDown = e => {\n    switch (e.key) {\n      case Keys.HOME:\n        dispatch(HoverActionTypes.FIRST);\n        break;\n      case Keys.END:\n        dispatch(HoverActionTypes.LAST);\n        break;\n      case Keys.UP:\n        dispatch(HoverActionTypes.DECREASE, hoverItem);\n        break;\n      case Keys.DOWN:\n        dispatch(HoverActionTypes.INCREASE, hoverItem);\n        break;\n      case Keys.SPACE:\n        if (e.target && e.target.className.indexOf(menuClass) !== -1) {\n          e.preventDefault();\n        }\n        return;\n      default:\n        return;\n    }\n    e.preventDefault();\n    e.stopPropagation();\n  };\n  const onAnimationEnd = () => {\n    if (state === 'closing') {\n      setOverflowData();\n    }\n    safeCall(endTransition);\n  };\n  const onPointerMove = e => {\n    e.stopPropagation();\n    submenuCtx.on(submenuCloseDelay, () => {\n      dispatch(HoverActionTypes.RESET);\n      focusRef.current.focus();\n    });\n  };\n  const onPointerLeave = e => {\n    if (e.target === e.currentTarget) submenuCtx.off();\n  };\n  const handlePosition = useCallback(noOverflowCheck => {\n    var _anchorRef$current;\n    const anchorRect = anchorRef ? (_anchorRef$current = anchorRef.current) == null ? void 0 : _anchorRef$current.getBoundingClientRect() : anchorPoint ? {\n      left: anchorPoint.x,\n      right: anchorPoint.x,\n      top: anchorPoint.y,\n      bottom: anchorPoint.y,\n      width: 0,\n      height: 0\n    } : null;\n    if (!anchorRect) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn('[React-Menu] Menu might not be positioned properly as one of the anchorRef or anchorPoint prop should be provided. If `anchorRef` is provided, the anchor must be mounted before menu is open.');\n      }\n      return;\n    }\n    if (!scrollNodes.menu) {\n      scrollNodes.menu = (boundingBoxRef ? boundingBoxRef.current : getScrollAncestor(rootMenuRef.current)) || window;\n    }\n    const positionHelpers = getPositionHelpers(containerRef, menuRef, scrollNodes.menu, boundingBoxPadding);\n    let {\n      arrowX,\n      arrowY,\n      x,\n      y,\n      computedDirection\n    } = positionMenu({\n      arrow,\n      align,\n      direction,\n      gap,\n      shift,\n      position,\n      anchorRect,\n      arrowRef,\n      positionHelpers\n    });\n    const {\n      menuRect\n    } = positionHelpers;\n    let menuHeight = menuRect.height;\n    if (!noOverflowCheck && overflow !== 'visible') {\n      const {\n        getTopOverflow,\n        getBottomOverflow\n      } = positionHelpers;\n      let height, overflowAmt;\n      const prevHeight = latestMenuSize.current.height;\n      const bottomOverflow = getBottomOverflow(y);\n      if (bottomOverflow > 0 || floatEqual(bottomOverflow, 0) && floatEqual(menuHeight, prevHeight)) {\n        height = menuHeight - bottomOverflow;\n        overflowAmt = bottomOverflow;\n      } else {\n        const topOverflow = getTopOverflow(y);\n        if (topOverflow < 0 || floatEqual(topOverflow, 0) && floatEqual(menuHeight, prevHeight)) {\n          height = menuHeight + topOverflow;\n          overflowAmt = 0 - topOverflow;\n          if (height >= 0) y -= topOverflow;\n        }\n      }\n      if (height >= 0) {\n        menuHeight = height;\n        setOverflowData({\n          height,\n          overflowAmt\n        });\n      } else {\n        setOverflowData();\n      }\n    }\n    if (arrow) setArrowPosition({\n      x: arrowX,\n      y: arrowY\n    });\n    setMenuPosition({\n      x,\n      y\n    });\n    setExpandedDirection(computedDirection);\n    latestMenuSize.current = {\n      width: menuRect.width,\n      height: menuHeight\n    };\n  }, [arrow, align, boundingBoxPadding, direction, gap, shift, position, overflow, anchorPoint, anchorRef, containerRef, boundingBoxRef, rootMenuRef, scrollNodes]);\n  useIsomorphicLayoutEffect(() => {\n    if (isOpen) {\n      handlePosition();\n      if (prevOpen.current) forceReposSubmenu();\n    }\n    prevOpen.current = isOpen;\n    latestHandlePosition.current = handlePosition;\n  }, [isOpen, handlePosition, reposFlag]);\n  useIsomorphicLayoutEffect(() => {\n    if (overflowData && !setDownOverflow) menuRef.current.scrollTop = 0;\n  }, [overflowData, setDownOverflow]);\n  useIsomorphicLayoutEffect(() => updateItems, [updateItems]);\n  useEffect(() => {\n    let {\n      menu: menuScroll\n    } = scrollNodes;\n    if (!isOpen || !menuScroll) return;\n    menuScroll = menuScroll.addEventListener ? menuScroll : window;\n    if (!scrollNodes.anchors) {\n      scrollNodes.anchors = [];\n      let anchorScroll = getScrollAncestor(rootAnchorRef && rootAnchorRef.current);\n      while (anchorScroll && anchorScroll !== menuScroll) {\n        scrollNodes.anchors.push(anchorScroll);\n        anchorScroll = getScrollAncestor(anchorScroll);\n      }\n    }\n    let scroll = viewScroll;\n    if (scrollNodes.anchors.length && scroll === 'initial') scroll = 'auto';\n    if (scroll === 'initial') return;\n    const handleScroll = () => {\n      if (scroll === 'auto') {\n        batchedUpdates(() => handlePosition(true));\n      } else {\n        safeCall(onClose, {\n          reason: CloseReason.SCROLL\n        });\n      }\n    };\n    const scrollObservers = scrollNodes.anchors.concat(viewScroll !== 'initial' ? menuScroll : []);\n    scrollObservers.forEach(o => o.addEventListener('scroll', handleScroll));\n    return () => scrollObservers.forEach(o => o.removeEventListener('scroll', handleScroll));\n  }, [rootAnchorRef, scrollNodes, isOpen, onClose, viewScroll, handlePosition]);\n  const hasOverflow = !!overflowData && overflowData.overflowAmt > 0;\n  useEffect(() => {\n    if (hasOverflow || !isOpen || !parentScrollingRef) return;\n    const handleScroll = () => batchedUpdates(handlePosition);\n    const parentScroll = parentScrollingRef.current;\n    parentScroll.addEventListener('scroll', handleScroll);\n    return () => parentScroll.removeEventListener('scroll', handleScroll);\n  }, [isOpen, hasOverflow, parentScrollingRef, handlePosition]);\n  useEffect(() => {\n    if (typeof ResizeObserver !== 'function' || reposition === 'initial') return;\n    const resizeObserver = new ResizeObserver(([entry]) => {\n      const {\n        borderBoxSize,\n        target\n      } = entry;\n      let width, height;\n      if (borderBoxSize) {\n        const {\n          inlineSize,\n          blockSize\n        } = borderBoxSize[0] || borderBoxSize;\n        width = inlineSize;\n        height = blockSize;\n      } else {\n        const borderRect = target.getBoundingClientRect();\n        width = borderRect.width;\n        height = borderRect.height;\n      }\n      if (width === 0 || height === 0) return;\n      if (floatEqual(width, latestMenuSize.current.width, 1) && floatEqual(height, latestMenuSize.current.height, 1)) return;\n      flushSync(() => {\n        latestHandlePosition.current();\n        forceReposSubmenu();\n      });\n    });\n    const observeTarget = menuRef.current;\n    resizeObserver.observe(observeTarget, {\n      box: 'border-box'\n    });\n    return () => resizeObserver.unobserve(observeTarget);\n  }, [reposition]);\n  useEffect(() => {\n    if (!isOpen) {\n      dispatch(HoverActionTypes.RESET);\n      if (!closeTransition) setOverflowData();\n      return;\n    }\n    const {\n      position,\n      alwaysUpdate\n    } = menuItemFocus || {};\n    const setItemFocus = () => {\n      if (position === FocusPositions.FIRST) {\n        dispatch(HoverActionTypes.FIRST);\n      } else if (position === FocusPositions.LAST) {\n        dispatch(HoverActionTypes.LAST);\n      } else if (position >= -1) {\n        dispatch(HoverActionTypes.SET_INDEX, undefined, position);\n      }\n    };\n    if (alwaysUpdate) {\n      setItemFocus();\n    } else if (captureFocus) {\n      const id = setTimeout(() => {\n        const menuElt = menuRef.current;\n        if (menuElt && !menuElt.contains(document.activeElement)) {\n          focusRef.current.focus();\n          setItemFocus();\n        }\n      }, openTransition ? 170 : 100);\n      return () => clearTimeout(id);\n    }\n  }, [isOpen, openTransition, closeTransition, captureFocus, menuItemFocus, dispatch]);\n  const itemContext = useMemo(() => ({\n    isParentOpen: isOpen,\n    submenuCtx,\n    dispatch,\n    updateItems\n  }), [isOpen, submenuCtx, dispatch, updateItems]);\n  let maxHeight, overflowAmt;\n  if (overflowData) {\n    setDownOverflow ? overflowAmt = overflowData.overflowAmt : maxHeight = overflowData.height;\n  }\n  const listContext = useMemo(() => ({\n    reposSubmenu,\n    submenuCtx,\n    overflow,\n    overflowAmt,\n    parentMenuRef: menuRef,\n    parentDir: expandedDirection\n  }), [reposSubmenu, submenuCtx, overflow, overflowAmt, expandedDirection]);\n  const overflowStyle = maxHeight >= 0 ? {\n    maxHeight,\n    overflow\n  } : undefined;\n  const modifiers = useMemo(() => ({\n    state,\n    dir: expandedDirection\n  }), [state, expandedDirection]);\n  const arrowModifiers = useMemo(() => ({\n    dir: expandedDirection\n  }), [expandedDirection]);\n  const _arrowClassName = useBEM({\n    block: menuClass,\n    element: menuArrowClass,\n    modifiers: arrowModifiers,\n    className: arrowProps.className\n  });\n  const menu = /*#__PURE__*/jsxs(\"ul\", {\n    role: \"menu\",\n    \"aria-label\": ariaLabel,\n    ...commonProps(isDisabled),\n    ...mergeProps({\n      onPointerEnter: parentSubmenuCtx == null ? void 0 : parentSubmenuCtx.off,\n      onPointerMove,\n      onPointerLeave,\n      onKeyDown,\n      onAnimationEnd\n    }, restProps),\n    ref: useCombinedRef(externalRef, menuRef),\n    className: useBEM({\n      block: menuClass,\n      modifiers,\n      className: menuClassName\n    }),\n    style: {\n      ...menuStyle,\n      ...overflowStyle,\n      margin: 0,\n      display: state === 'closed' ? 'none' : undefined,\n      position: positionAbsolute,\n      left: menuPosition.x,\n      top: menuPosition.y\n    },\n    children: [/*#__PURE__*/jsx(\"li\", {\n      tabIndex: -1,\n      style: {\n        position: positionAbsolute,\n        left: 0,\n        top: 0,\n        display: 'block',\n        outline: 'none'\n      },\n      ref: focusRef,\n      ...dummyItemProps,\n      ...focusProps\n    }), arrow && /*#__PURE__*/jsx(\"li\", {\n      ...dummyItemProps,\n      ...arrowProps,\n      className: _arrowClassName,\n      style: {\n        display: 'block',\n        position: positionAbsolute,\n        left: arrowPosition.x,\n        top: arrowPosition.y,\n        ...arrowProps.style\n      },\n      ref: arrowRef\n    }), /*#__PURE__*/jsx(MenuListContext.Provider, {\n      value: listContext,\n      children: /*#__PURE__*/jsx(MenuListItemContext.Provider, {\n        value: itemContext,\n        children: /*#__PURE__*/jsx(HoverItemContext.Provider, {\n          value: hoverItem,\n          children: safeCall(children, modifiers)\n        })\n      })\n    })]\n  });\n  return containerProps ? /*#__PURE__*/jsx(MenuContainer, {\n    ...containerProps,\n    isOpen: isOpen,\n    children: menu\n  }) : menu;\n};\n\nexport { MenuList };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}