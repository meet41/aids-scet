{"ast":null,"code":"/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport '../environment/dev.js';\nimport { createResourceUrlInternal, unwrapResourceUrl } from '../internals/resource_url_impl.js';\nimport { unwrapScript } from '../internals/script_impl.js';\nimport { assertIsTemplateObject } from '../internals/string_literal.js';\n/**\n * Check whether the base url contains a valid origin,\n *\n * A string for an origin must contain only alphanumeric or any of the\n * following: `-.:`, and must not be an IP address. Remember that, as per the\n * documentation for TrustedResourceUrl, the origin must be trustworthy.\n *\n * @param base The base url that contains an origin.\n */\nfunction hasValidOrigin(base) {\n  if (!(/^https:\\/\\//.test(base) || /^\\/\\//.test(base))) {\n    return false;\n  }\n  const originStart = base.indexOf('//') + 2;\n  const originEnd = base.indexOf('/', originStart);\n  // If the base url only contains the prefix (e.g. //), or the slash\n  // for the origin is right after the prefix (e.g. ///), the origin is\n  // missing.\n  if (originEnd <= originStart) {\n    throw new Error(`Can't interpolate data in a url's origin, ` + `Please make sure to fully specify the origin, terminated with '/'.`);\n  }\n  const origin = base.substring(originStart, originEnd);\n  if (!/^[0-9a-z.:-]+$/i.test(origin)) {\n    throw new Error('The origin contains unsupported characters.');\n  }\n  if (!/^[^:]*(:[0-9]+)?$/i.test(origin)) {\n    throw new Error('Invalid port number.');\n  }\n  if (!/(^|\\.)[a-z][^.]*$/i.test(origin)) {\n    throw new Error('The top-level domain must start with a letter.');\n  }\n  return true;\n}\n/**\n * Check whether the base url contains a valid about url at its beginning.\n *\n * An about url is either exactly 'about:blank' or 'about:blank#<str>' where\n * <str> can be an arbitrary string.\n *\n * @param base The base url.\n */\nfunction isValidAboutUrl(base) {\n  if (!/^about:blank/.test(base)) {\n    return false;\n  }\n  if (base !== 'about:blank' && !/^about:blank#/.test(base)) {\n    throw new Error('The about url is invalid.');\n  }\n  return true;\n}\n/**\n * Check whether the base url contains a valid path start at its beginning.\n *\n * A valid path start is either a '/' or a '/' followed by at least one\n * character that is not '/' or '\\'.\n *\n * @param base The base url.\n */\nfunction isValidPathStart(base) {\n  if (!/^\\//.test(base)) {\n    return false;\n  }\n  if (base === '/' || base.length > 1 && base[1] !== '/' && base[1] !== '\\\\') {\n    return true;\n  }\n  throw new Error('The path start in the url is invalid.');\n}\n/**\n * Check whether the base url contains a valid relative path start at its\n * beginning.\n *\n * A valid relative path start is a non empty string that has no ':', '/' nor\n * '\\', and that is followed by a '/'.\n *\n * @param base The base url.\n */\nfunction isValidRelativePathStart(base) {\n  // Using the RegExp syntax as the native JS RegExp syntax is not well handled\n  // by some downstream bundlers with this regex.\n  return new RegExp('^[^:\\\\s\\\\\\\\/]+/').test(base);\n}\n/**\n * Splits an url into segments using '?' and '#' delimiters.\n *\n * The URL can later be put back together by concatenating the returned segments\n * like: path + params + hash. Note that the delimiters '?' and '#' will\n * already be included in 'params' and 'hash' values respectively when these are\n * not empty.\n *\n * @param url The url to split.\n */\nfunction getUrlSegments(url) {\n  const segments = url.split(/\\?|#/);\n  const params = /\\?/.test(url) ? '?' + segments[1] : '';\n  const hash = /#/.test(url) ? '#' + (params ? segments[2] : segments[1]) : '';\n  return {\n    path: segments[0],\n    params,\n    hash\n  };\n}\n/**\n * Builds TrustedResourceUrl from a template literal.\n *\n * This factory is a template literal tag function. It should be called with\n * a template literal, with or without embedded expressions. For example,\n *               trustedResourceUrl`//example.com/${bar}`;\n * or\n *               trustedResourceUrl`//example.com`;\n *\n * When this function is called with a template literal without any embedded\n * expressions, the template string may contain anything as the whole URL is\n * a compile-time string constant.\n *\n * When this function is called with a template literal that contains embedded\n * expressions, the template must start with one of the following:\n * - `https://<origin>/`\n * - `//<origin>/`\n * - `/<pathStart>`\n * - `<relativePathStart>/`\n * - `about:blank`\n * - `data:`\n *\n * `<origin>` must contain only alphanumeric or any of the following: `-.:`.\n * Remember that, as per the documentation for TrustedResourceUrl, the origin\n * must be trustworthy. An origin of \"example.com\" could be set with this\n * method, but would tie the security of your site to the security of\n * example.com. Similarly, formats that potentially cover redirects hosted\n * on a trusted origin are problematic, since that could lead to untrusted\n * origins.\n *\n * `<pathStart>` is either an empty string, or a non empty string that does not\n * start with '/' or '\\'.\n * In other words, `/<pathStart>` is either a '/' or a\n * '/' followed by at least one character that is not '/' or '\\'.\n *\n * `<relativePathStart> is a non empty string that has no ':', '/' nor '\\'.\n *\n * `data:` (data URL) does not allow embedded expressions in the template\n * literal input.\n *\n * All embedded expressions are URL encoded when they are interpolated. Do not\n * embed expressions that are already URL encoded as they will be double encoded\n * by the builder.\n *\n * @param templateObj This contains the literal part of the template literal.\n * @param rest This represents the template's embedded expressions.\n */\nexport function trustedResourceUrl(templateObj, ...rest) {\n  // Check if templateObj is actually from a template literal.\n  if (process.env.NODE_ENV !== 'production') {\n    assertIsTemplateObject(templateObj, rest.length);\n  }\n  if (rest.length === 0) {\n    return createResourceUrlInternal(templateObj[0]);\n  }\n  const base = templateObj[0].toLowerCase();\n  if (process.env.NODE_ENV !== 'production') {\n    if (/^data:/.test(base)) {\n      throw new Error('Data URLs cannot have expressions in the template literal input.');\n    }\n    if (!hasValidOrigin(base) && !isValidPathStart(base) && !isValidRelativePathStart(base) && !isValidAboutUrl(base)) {\n      throw new Error('Trying to interpolate expressions in an unsupported url format.');\n    }\n  }\n  let url = templateObj[0];\n  for (let i = 0; i < rest.length; i++) {\n    url += encodeURIComponent(rest[i]) + templateObj[i + 1];\n  }\n  return createResourceUrlInternal(url);\n}\n/**\n * Creates a new TrustedResourceUrl with params added to the URL's search\n * parameters.\n *\n * @param params What to add to the URL. Parameters with value `null` or\n * `undefined` are skipped. Both keys and values will be encoded. Do not pass\n * pre-encoded values as this will result them being double encoded. If the\n * value is an array then the same parameter is added for every element in the\n * array.\n */\nexport function appendParams(trustedUrl, params) {\n  const urlSegments = getUrlSegments(unwrapResourceUrl(trustedUrl).toString());\n  let urlParams = urlSegments.params;\n  let separator = urlParams.length ? '&' : '?';\n  // for-of has a big polyfill.\n  // tslint:disable-next-line:ban-iterable-foreach\n  params.forEach((value, key) => {\n    const values = value instanceof Array ? value : [value];\n    for (let i = 0; i < values.length; i++) {\n      const v = values[i];\n      if (v === null || v === undefined) {\n        continue;\n      }\n      urlParams += separator + encodeURIComponent(key) + '=' + encodeURIComponent(String(v));\n      separator = '&';\n    }\n  });\n  return createResourceUrlInternal(urlSegments.path + urlParams + urlSegments.hash);\n}\nconst BEFORE_FRAGMENT_REGEXP = /[^#]*/;\n/**\n * Creates a new TrustedResourceUrl based on an existing one but with the\n * addition of a fragment (the part after `#`). If the URL already has a\n * fragment, it is replaced with the new one.\n * @param fragment The fragment to add to the URL, verbatim, without the leading\n * `#`. No additional escaping is applied.\n */\nexport function replaceFragment(trustedUrl, fragment) {\n  const urlString = unwrapResourceUrl(trustedUrl).toString();\n  return createResourceUrlInternal(BEFORE_FRAGMENT_REGEXP.exec(urlString)[0] + '#' + fragment);\n}\n/**\n * Creates a new TrustedResourceUrl based on an existing one with a single\n * subpath segment added to the end of the existing path and prior to any query\n * parameters and/or fragments that already exist in the URL.\n * @param pathSegment The singular sub path being added to the URL. Do not pass\n *     a pre-encoded value as this will result in it being double encoded.\n */\nexport function appendPathSegment(trustedUrl, pathSegment) {\n  const urlSegments = getUrlSegments(unwrapResourceUrl(trustedUrl).toString());\n  const separator = urlSegments.path.slice(-1) === '/' ? '' : '/';\n  const newPath = urlSegments.path + separator + encodeURIComponent(pathSegment);\n  return createResourceUrlInternal(newPath + urlSegments.params + urlSegments.hash);\n}\n/**\n * Creates a `TrustedResourceUrl` by generating a `Blob` from a\n * `SafeScript` and then calling `URL.createObjectURL` with that `Blob`.\n *\n * Caller must call `URL.revokeObjectURL()` on the stringified url to\n * release the underlying `Blob`.\n */\nexport function objectUrlFromScript(safeScript) {\n  const scriptContent = unwrapScript(safeScript).toString();\n  const blob = new Blob([scriptContent], {\n    type: 'text/javascript'\n  });\n  return createResourceUrlInternal(URL.createObjectURL(blob));\n}\n/**\n * A function to safely retrieve the base URI from the Window object and set it\n * at the beginning of a given path-relative (starts with \"/\") resource url.\n *\n * @param pathRelativeUrl The resource to which the origin shall be prepended.\n */\nexport function toAbsoluteResourceUrl(pathRelativeUrl) {\n  const originalUrl = unwrapResourceUrl(pathRelativeUrl).toString();\n  const qualifiedUrl = new URL(originalUrl, window.document.baseURI);\n  return createResourceUrlInternal(qualifiedUrl.toString());\n}","map":{"version":3,"names":["createResourceUrlInternal","unwrapResourceUrl","unwrapScript","assertIsTemplateObject","hasValidOrigin","base","test","originStart","indexOf","originEnd","Error","origin","substring","isValidAboutUrl","isValidPathStart","length","isValidRelativePathStart","RegExp","getUrlSegments","url","segments","split","params","hash","path","trustedResourceUrl","templateObj","rest","process","env","NODE_ENV","toLowerCase","i","encodeURIComponent","appendParams","trustedUrl","urlSegments","toString","urlParams","separator","forEach","value","key","values","Array","v","undefined","String","BEFORE_FRAGMENT_REGEXP","replaceFragment","fragment","urlString","exec","appendPathSegment","pathSegment","slice","newPath","objectUrlFromScript","safeScript","scriptContent","blob","Blob","type","URL","createObjectURL","toAbsoluteResourceUrl","pathRelativeUrl","originalUrl","qualifiedUrl","window","document","baseURI"],"sources":["E:/HTML/Udemy_Full Stack Web/AI-SCET Website/aiscet/node_modules/safevalues/dist/mjs/builders/resource_url_builders.js"],"sourcesContent":["/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport '../environment/dev.js';\nimport { createResourceUrlInternal, unwrapResourceUrl, } from '../internals/resource_url_impl.js';\nimport { unwrapScript } from '../internals/script_impl.js';\nimport { assertIsTemplateObject } from '../internals/string_literal.js';\n/**\n * Check whether the base url contains a valid origin,\n *\n * A string for an origin must contain only alphanumeric or any of the\n * following: `-.:`, and must not be an IP address. Remember that, as per the\n * documentation for TrustedResourceUrl, the origin must be trustworthy.\n *\n * @param base The base url that contains an origin.\n */\nfunction hasValidOrigin(base) {\n    if (!(/^https:\\/\\//.test(base) || /^\\/\\//.test(base))) {\n        return false;\n    }\n    const originStart = base.indexOf('//') + 2;\n    const originEnd = base.indexOf('/', originStart);\n    // If the base url only contains the prefix (e.g. //), or the slash\n    // for the origin is right after the prefix (e.g. ///), the origin is\n    // missing.\n    if (originEnd <= originStart) {\n        throw new Error(`Can't interpolate data in a url's origin, ` +\n            `Please make sure to fully specify the origin, terminated with '/'.`);\n    }\n    const origin = base.substring(originStart, originEnd);\n    if (!/^[0-9a-z.:-]+$/i.test(origin)) {\n        throw new Error('The origin contains unsupported characters.');\n    }\n    if (!/^[^:]*(:[0-9]+)?$/i.test(origin)) {\n        throw new Error('Invalid port number.');\n    }\n    if (!/(^|\\.)[a-z][^.]*$/i.test(origin)) {\n        throw new Error('The top-level domain must start with a letter.');\n    }\n    return true;\n}\n/**\n * Check whether the base url contains a valid about url at its beginning.\n *\n * An about url is either exactly 'about:blank' or 'about:blank#<str>' where\n * <str> can be an arbitrary string.\n *\n * @param base The base url.\n */\nfunction isValidAboutUrl(base) {\n    if (!/^about:blank/.test(base)) {\n        return false;\n    }\n    if (base !== 'about:blank' && !/^about:blank#/.test(base)) {\n        throw new Error('The about url is invalid.');\n    }\n    return true;\n}\n/**\n * Check whether the base url contains a valid path start at its beginning.\n *\n * A valid path start is either a '/' or a '/' followed by at least one\n * character that is not '/' or '\\'.\n *\n * @param base The base url.\n */\nfunction isValidPathStart(base) {\n    if (!/^\\//.test(base)) {\n        return false;\n    }\n    if (base === '/' ||\n        (base.length > 1 && base[1] !== '/' && base[1] !== '\\\\')) {\n        return true;\n    }\n    throw new Error('The path start in the url is invalid.');\n}\n/**\n * Check whether the base url contains a valid relative path start at its\n * beginning.\n *\n * A valid relative path start is a non empty string that has no ':', '/' nor\n * '\\', and that is followed by a '/'.\n *\n * @param base The base url.\n */\nfunction isValidRelativePathStart(base) {\n    // Using the RegExp syntax as the native JS RegExp syntax is not well handled\n    // by some downstream bundlers with this regex.\n    return new RegExp('^[^:\\\\s\\\\\\\\/]+/').test(base);\n}\n/**\n * Splits an url into segments using '?' and '#' delimiters.\n *\n * The URL can later be put back together by concatenating the returned segments\n * like: path + params + hash. Note that the delimiters '?' and '#' will\n * already be included in 'params' and 'hash' values respectively when these are\n * not empty.\n *\n * @param url The url to split.\n */\nfunction getUrlSegments(url) {\n    const segments = url.split(/\\?|#/);\n    const params = /\\?/.test(url) ? '?' + segments[1] : '';\n    const hash = /#/.test(url) ? '#' + (params ? segments[2] : segments[1]) : '';\n    return { path: segments[0], params, hash };\n}\n/**\n * Builds TrustedResourceUrl from a template literal.\n *\n * This factory is a template literal tag function. It should be called with\n * a template literal, with or without embedded expressions. For example,\n *               trustedResourceUrl`//example.com/${bar}`;\n * or\n *               trustedResourceUrl`//example.com`;\n *\n * When this function is called with a template literal without any embedded\n * expressions, the template string may contain anything as the whole URL is\n * a compile-time string constant.\n *\n * When this function is called with a template literal that contains embedded\n * expressions, the template must start with one of the following:\n * - `https://<origin>/`\n * - `//<origin>/`\n * - `/<pathStart>`\n * - `<relativePathStart>/`\n * - `about:blank`\n * - `data:`\n *\n * `<origin>` must contain only alphanumeric or any of the following: `-.:`.\n * Remember that, as per the documentation for TrustedResourceUrl, the origin\n * must be trustworthy. An origin of \"example.com\" could be set with this\n * method, but would tie the security of your site to the security of\n * example.com. Similarly, formats that potentially cover redirects hosted\n * on a trusted origin are problematic, since that could lead to untrusted\n * origins.\n *\n * `<pathStart>` is either an empty string, or a non empty string that does not\n * start with '/' or '\\'.\n * In other words, `/<pathStart>` is either a '/' or a\n * '/' followed by at least one character that is not '/' or '\\'.\n *\n * `<relativePathStart> is a non empty string that has no ':', '/' nor '\\'.\n *\n * `data:` (data URL) does not allow embedded expressions in the template\n * literal input.\n *\n * All embedded expressions are URL encoded when they are interpolated. Do not\n * embed expressions that are already URL encoded as they will be double encoded\n * by the builder.\n *\n * @param templateObj This contains the literal part of the template literal.\n * @param rest This represents the template's embedded expressions.\n */\nexport function trustedResourceUrl(templateObj, ...rest) {\n    // Check if templateObj is actually from a template literal.\n    if (process.env.NODE_ENV !== 'production') {\n        assertIsTemplateObject(templateObj, rest.length);\n    }\n    if (rest.length === 0) {\n        return createResourceUrlInternal(templateObj[0]);\n    }\n    const base = templateObj[0].toLowerCase();\n    if (process.env.NODE_ENV !== 'production') {\n        if (/^data:/.test(base)) {\n            throw new Error('Data URLs cannot have expressions in the template literal input.');\n        }\n        if (!hasValidOrigin(base) &&\n            !isValidPathStart(base) &&\n            !isValidRelativePathStart(base) &&\n            !isValidAboutUrl(base)) {\n            throw new Error('Trying to interpolate expressions in an unsupported url format.');\n        }\n    }\n    let url = templateObj[0];\n    for (let i = 0; i < rest.length; i++) {\n        url += encodeURIComponent(rest[i]) + templateObj[i + 1];\n    }\n    return createResourceUrlInternal(url);\n}\n/**\n * Creates a new TrustedResourceUrl with params added to the URL's search\n * parameters.\n *\n * @param params What to add to the URL. Parameters with value `null` or\n * `undefined` are skipped. Both keys and values will be encoded. Do not pass\n * pre-encoded values as this will result them being double encoded. If the\n * value is an array then the same parameter is added for every element in the\n * array.\n */\nexport function appendParams(trustedUrl, params) {\n    const urlSegments = getUrlSegments(unwrapResourceUrl(trustedUrl).toString());\n    let urlParams = urlSegments.params;\n    let separator = urlParams.length ? '&' : '?';\n    // for-of has a big polyfill.\n    // tslint:disable-next-line:ban-iterable-foreach\n    params.forEach((value, key) => {\n        const values = value instanceof Array ? value : [value];\n        for (let i = 0; i < values.length; i++) {\n            const v = values[i];\n            if (v === null || v === undefined) {\n                continue;\n            }\n            urlParams +=\n                separator +\n                    encodeURIComponent(key) +\n                    '=' +\n                    encodeURIComponent(String(v));\n            separator = '&';\n        }\n    });\n    return createResourceUrlInternal(urlSegments.path + urlParams + urlSegments.hash);\n}\nconst BEFORE_FRAGMENT_REGEXP = /[^#]*/;\n/**\n * Creates a new TrustedResourceUrl based on an existing one but with the\n * addition of a fragment (the part after `#`). If the URL already has a\n * fragment, it is replaced with the new one.\n * @param fragment The fragment to add to the URL, verbatim, without the leading\n * `#`. No additional escaping is applied.\n */\nexport function replaceFragment(trustedUrl, fragment) {\n    const urlString = unwrapResourceUrl(trustedUrl).toString();\n    return createResourceUrlInternal(BEFORE_FRAGMENT_REGEXP.exec(urlString)[0] + '#' + fragment);\n}\n/**\n * Creates a new TrustedResourceUrl based on an existing one with a single\n * subpath segment added to the end of the existing path and prior to any query\n * parameters and/or fragments that already exist in the URL.\n * @param pathSegment The singular sub path being added to the URL. Do not pass\n *     a pre-encoded value as this will result in it being double encoded.\n */\nexport function appendPathSegment(trustedUrl, pathSegment) {\n    const urlSegments = getUrlSegments(unwrapResourceUrl(trustedUrl).toString());\n    const separator = urlSegments.path.slice(-1) === '/' ? '' : '/';\n    const newPath = urlSegments.path + separator + encodeURIComponent(pathSegment);\n    return createResourceUrlInternal(newPath + urlSegments.params + urlSegments.hash);\n}\n/**\n * Creates a `TrustedResourceUrl` by generating a `Blob` from a\n * `SafeScript` and then calling `URL.createObjectURL` with that `Blob`.\n *\n * Caller must call `URL.revokeObjectURL()` on the stringified url to\n * release the underlying `Blob`.\n */\nexport function objectUrlFromScript(safeScript) {\n    const scriptContent = unwrapScript(safeScript).toString();\n    const blob = new Blob([scriptContent], { type: 'text/javascript' });\n    return createResourceUrlInternal(URL.createObjectURL(blob));\n}\n/**\n * A function to safely retrieve the base URI from the Window object and set it\n * at the beginning of a given path-relative (starts with \"/\") resource url.\n *\n * @param pathRelativeUrl The resource to which the origin shall be prepended.\n */\nexport function toAbsoluteResourceUrl(pathRelativeUrl) {\n    const originalUrl = unwrapResourceUrl(pathRelativeUrl).toString();\n    const qualifiedUrl = new URL(originalUrl, window.document.baseURI);\n    return createResourceUrlInternal(qualifiedUrl.toString());\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}